<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Poker Equity Calculator</title>
  <style>
    :root {
      --felt-a: #063e2a;
      --felt-b: #0a5a3b;
      --felt-c: #0f6f4a;
      --panel-bg: rgba(11, 24, 19, 0.78);
      --panel-border: rgba(255, 214, 117, 0.24);
      --panel-shadow: 0 14px 32px rgba(0, 0, 0, 0.35);
      --text-main: #f1f8f2;
      --text-soft: #bcd6c3;
      --text-dim: #90aa99;
      --accent: #ffd469;
      --accent-strong: #ffbf2f;
      --danger: #ff6f6f;
      --ok: #7de4a0;
      --radius-lg: 16px;
      --radius-md: 12px;
      --radius-sm: 9px;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --font-1: 12px;
      --font-2: 14px;
      --font-3: 16px;
      --font-4: 20px;
      --font-5: 26px;
      --bottom-nav-height: 66px;
      --safe-bottom: calc(var(--bottom-nav-height) + env(safe-area-inset-bottom));
      --range-cell-size: 44px;
      --range-font-size: 12px;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      padding: var(--space-3);
      padding-bottom: calc(var(--safe-bottom) + var(--space-4));
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 20% -10%, rgba(255, 224, 162, 0.15), transparent 45%),
        radial-gradient(circle at 80% 120%, rgba(0, 0, 0, 0.55), transparent 48%),
        linear-gradient(150deg, var(--felt-a), var(--felt-b) 55%, var(--felt-c));
      line-height: 1.45;
      -webkit-tap-highlight-color: transparent;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.025) 0 2px, transparent 2px 8px);
      opacity: 0.22;
      z-index: -1;
    }

    .container {
      max-width: 1080px;
      margin: 0 auto;
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-lg);
      background: var(--panel-bg);
      box-shadow: var(--panel-shadow);
      padding: var(--space-4);
      backdrop-filter: blur(8px);
    }

    .app-header {
      margin-bottom: var(--space-4);
    }

    h1 {
      margin: 0;
      font-size: clamp(24px, 4.5vw, 34px);
      letter-spacing: 0.01em;
    }

    h2 {
      margin: var(--space-3) 0 var(--space-2);
      font-size: clamp(18px, 3.8vw, 24px);
    }

    h3 {
      margin: 0;
      font-size: clamp(16px, 3.4vw, 20px);
    }

    p {
      margin: var(--space-2) 0;
    }

    .tab-menu {
      display: none;
    }

    .tab-content {
      display: none;
      padding: var(--space-2) 0 var(--space-3);
      animation: tabFade 0.24s ease;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes tabFade {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .surface-card {
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-md);
      padding: var(--space-3);
      margin: var(--space-3) 0;
      background: rgba(8, 18, 15, 0.6);
      box-shadow: inset 0 1px 0 rgba(255, 240, 204, 0.08);
    }

    .surface-card.tight {
      padding: var(--space-2) var(--space-3);
    }

    .section-label {
      margin: 0 0 var(--space-2);
      color: var(--text-soft);
      font-size: var(--font-2);
    }

    .chip-text {
      display: inline-block;
      margin-right: var(--space-2);
      color: var(--accent);
      font-weight: 800;
      letter-spacing: 0.03em;
    }

    input,
    select {
      width: 100%;
      margin-top: var(--space-1);
      padding: 10px 12px;
      border: 1px solid rgba(255, 233, 179, 0.26);
      border-radius: var(--radius-sm);
      background: rgba(9, 22, 17, 0.9);
      color: var(--text-main);
      font-size: var(--font-3);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    input:focus,
    select:focus {
      outline: 2px solid rgba(255, 212, 105, 0.5);
      outline-offset: 1px;
    }

    button {
      border: 1px solid rgba(255, 226, 153, 0.36);
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 28%, rgba(255, 245, 213, 0.3), transparent 60%),
        linear-gradient(180deg, #9e7417 0%, #7b5312 50%, #5c3e0e 100%);
      color: #fff6df;
      font-size: var(--font-2);
      font-weight: 700;
      letter-spacing: 0.02em;
      min-height: 42px;
      padding: 10px 14px;
      margin: var(--space-1) 0;
      cursor: pointer;
      transition: transform 0.14s ease, filter 0.14s ease, box-shadow 0.14s ease;
      box-shadow: 0 5px 12px rgba(0, 0, 0, 0.25);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
      touch-action: manipulation;
    }

    button:hover {
      filter: brightness(1.08);
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    button.cancel,
    .quick-ranges button.clear,
    .danger-btn {
      border-color: rgba(255, 175, 175, 0.55);
      background:
        radial-gradient(circle at 30% 28%, rgba(255, 220, 220, 0.3), transparent 60%),
        linear-gradient(180deg, #8f2f2f 0%, #6c1e1e 55%, #521313 100%);
    }

    button.secondary,
    .ghost-btn {
      border-color: rgba(158, 197, 174, 0.35);
      background:
        radial-gradient(circle at 30% 28%, rgba(224, 246, 236, 0.22), transparent 60%),
        linear-gradient(180deg, #28543e 0%, #1f3e2f 100%);
    }

    button.small {
      min-height: 36px;
      padding: 8px 11px;
      font-size: var(--font-1);
    }

    button:disabled {
      cursor: not-allowed;
      filter: grayscale(0.35);
      opacity: 0.6;
    }

    button[aria-pressed="true"] {
      border-color: rgba(255, 233, 166, 0.7);
      box-shadow: 0 0 0 2px rgba(255, 212, 105, 0.28), 0 6px 12px rgba(0, 0, 0, 0.32);
    }

    .button-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
      margin-top: var(--space-2);
    }

    .sticky-action-bar {
      position: sticky;
      bottom: calc(var(--safe-bottom) + var(--space-2));
      z-index: 18;
      padding: var(--space-2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 218, 126, 0.24);
      background: rgba(7, 17, 13, 0.9);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.36);
      backdrop-filter: blur(6px);
    }

    .selection-display {
      margin-top: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 221, 131, 0.2);
      background: rgba(8, 20, 15, 0.72);
      color: var(--text-soft);
      font-size: var(--font-2);
    }

    .selection-display span {
      color: var(--text-main);
      font-weight: 800;
      margin: 0 var(--space-1);
    }

    .card-grid-container,
    .range-grid-container,
    .icm-table-container {
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 216, 123, 0.2);
      background: rgba(8, 20, 16, 0.72);
    }

    #card-grid,
    #range-grid {
      border-collapse: separate;
      border-spacing: 6px;
      margin: 6px;
    }

    #card-grid td {
      width: 46px;
      min-width: 46px;
      height: 62px;
      border-radius: 10px;
      border: 2px solid #e4e4e4;
      background: linear-gradient(180deg, #ffffff 0%, #ececec 100%);
      color: #111;
      text-align: center;
      font-weight: 800;
      font-size: 17px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.24);
      cursor: pointer;
      position: relative;
      user-select: none;
      transition: transform 0.14s ease, box-shadow 0.14s ease, border-color 0.14s ease;
    }

    #card-grid td:hover {
      transform: translateY(-1px);
    }

    #card-grid td.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(255, 212, 105, 0.38), 0 8px 14px rgba(0, 0, 0, 0.35);
      transform: translateY(-2px);
    }

    #card-grid td.disabled {
      color: #747474;
      border-color: #8f8f8f;
      cursor: not-allowed;
      background:
        repeating-linear-gradient(135deg, #ececec 0 6px, #dbdbdb 6px 12px);
    }

    #card-grid td.disabled::after {
      content: "LOCK";
      position: absolute;
      inset: auto 4px 4px auto;
      padding: 1px 4px;
      border-radius: 4px;
      font-size: 9px;
      background: rgba(0, 0, 0, 0.68);
      color: #fff;
      letter-spacing: 0.04em;
    }

    #range-grid td {
      width: var(--range-cell-size);
      min-width: var(--range-cell-size);
      height: var(--range-cell-size);
      min-height: var(--range-cell-size);
      padding: 2px;
      border: 1px solid rgba(255, 244, 214, 0.33);
      border-radius: 11px;
      font-size: var(--range-font-size);
      text-align: center;
      font-weight: 800;
      color: #f8f4e8;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      transition: transform 0.1s ease, box-shadow 0.12s ease, border-color 0.12s ease;
      position: relative;
    }

    #range-grid td.pair {
      background: linear-gradient(180deg, #8d2f2f, #6f1f1f);
    }

    #range-grid td.suited {
      background: linear-gradient(180deg, #2c5f9f, #1e4070);
    }

    #range-grid td.offsuit {
      background: linear-gradient(180deg, #404040, #2f2f2f);
    }

    #range-grid td:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.28);
    }

    #range-grid td.active-range {
      border: 2px solid var(--accent);
      box-shadow: 0 0 0 2px rgba(255, 212, 105, 0.25), 0 8px 12px rgba(0, 0, 0, 0.28);
      filter: saturate(1.18);
      transform: translateY(-1px);
    }

    #range-grid td.hero-hand {
      outline: 2px solid #ff6e6e;
      outline-offset: 0;
    }

    #range-grid td.dragging-target {
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.7);
    }

    #range-grid-container.zoom-sm {
      --range-cell-size: 40px;
      --range-font-size: 11px;
    }

    #range-grid-container.zoom-md {
      --range-cell-size: 46px;
      --range-font-size: 12px;
    }

    #range-grid-container.zoom-lg {
      --range-cell-size: 56px;
      --range-font-size: 14px;
    }

    .red {
      color: #bf2f2f;
    }

    .black {
      color: #181818;
    }

    #equity-hud {
      position: static;
      margin-bottom: var(--space-3);
      border: 1px solid rgba(255, 212, 105, 0.4);
      border-radius: var(--radius-md);
      background:
        linear-gradient(180deg, rgba(19, 33, 26, 0.95), rgba(11, 20, 15, 0.95));
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(8px);
      overflow: hidden;
    }

    .hud-main {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
      padding: var(--space-3);
    }

    .hud-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .hud-title {
      color: var(--text-soft);
      font-size: var(--font-1);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 2px;
    }

    .hud-number {
      font-size: var(--font-4);
      font-weight: 900;
      color: var(--accent);
      letter-spacing: 0.03em;
    }

    #hud-equity-value {
      font-size: var(--font-5);
    }

    #hud-equity-error {
      color: var(--text-soft);
      font-size: var(--font-1);
      margin-left: var(--space-1);
    }

    #hud-hero-cards {
      display: flex;
      gap: var(--space-1);
    }

    .hud-card {
      min-width: 36px;
      height: 48px;
      border-radius: 8px;
      border: 2px solid rgba(255, 235, 176, 0.65);
      background: linear-gradient(180deg, #fefefe 0%, #ebebeb 100%);
      color: #141414;
      font-size: 18px;
      font-weight: 800;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
    }

    .hud-card.red {
      color: #b62929;
    }

    #hud-status-line {
      border-top: 1px solid rgba(255, 220, 143, 0.22);
      padding: var(--space-2) var(--space-3) calc(var(--space-2) + 1px);
      font-size: var(--font-2);
      color: var(--text-soft);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    #hud-status {
      font-weight: 800;
      color: var(--accent);
    }

    .status-positive,
    .status-negative,
    .status-neutral {
      font-weight: 800;
    }

    .status-positive::before {
      content: "[OK] ";
      font-weight: 900;
    }

    .status-negative::before {
      content: "[NG] ";
      font-weight: 900;
    }

    .status-neutral::before {
      content: "[..] ";
      font-weight: 900;
    }

    .status-positive {
      color: var(--ok);
    }

    .status-negative {
      color: var(--danger);
    }

    .status-neutral {
      color: var(--text-soft);
    }

    .quick-ranges {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
      margin: var(--space-2) 0;
    }

    .quick-ranges button {
      margin: 0;
      min-height: 38px;
      padding: 7px 12px;
      font-size: var(--font-1);
    }

    .range-tools {
      display: grid;
      gap: var(--space-2);
      margin: var(--space-2) 0;
    }

    .range-tools .range-zoom {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-2);
    }

    .range-tools .range-zoom button {
      margin: 0;
      min-width: 0;
      padding: 7px 12px;
    }

    .range-save {
      display: grid;
      gap: var(--space-2);
      margin-top: var(--space-3);
      border-top: 1px solid rgba(255, 221, 131, 0.2);
      padding-top: var(--space-3);
    }

    .range-save .inline-2 {
      display: grid;
      gap: var(--space-2);
      grid-template-columns: 1fr;
    }

    .sample-select {
      margin-top: var(--space-3);
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
    }

    .mode-note {
      margin: 0;
      color: var(--text-dim);
      font-size: var(--font-1);
    }

    #equity-precalc {
      margin-top: var(--space-2);
      border-style: dashed;
    }
    .ev-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
    }

    .ev-block h3 {
      margin-bottom: var(--space-2);
    }

    .ev-note {
      margin-top: 0;
      margin-bottom: var(--space-2);
    }

    .ev-out {
      margin-top: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 218, 126, 0.2);
      background: rgba(6, 15, 12, 0.64);
      color: var(--text-soft);
      font-size: var(--font-2);
      line-height: 1.55;
    }

    .ev-out .ev-value {
      color: var(--text-main);
      font-weight: 900;
    }

    .ev-out .ev-gap {
      font-weight: 800;
    }

    .ev-quick-bets {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: var(--space-2);
      margin-top: var(--space-2);
    }

    .ev-quick-bets button {
      margin: 0;
      min-height: 40px;
      font-size: 12px;
      padding: 8px 10px;
    }

    .ev-sticky-actions {
      margin-top: var(--space-3);
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: var(--space-2);
    }

    .ev-sticky-actions button {
      margin: 0;
      min-height: 44px;
    }

    .ev-result {
      margin-top: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-sm);
      background: rgba(6, 15, 12, 0.55);
      border: 1px solid rgba(255, 218, 126, 0.2);
      color: var(--text-soft);
      font-size: var(--font-2);
    }

    #ev-diff {
      font-size: 17px;
      font-weight: 900;
    }

    #ev-diff.ev-positive {
      color: var(--ok);
    }

    #ev-diff.ev-negative {
      color: var(--danger);
    }

    .ev-neutral {
      color: var(--text-soft);
    }

    .results {
      margin-top: var(--space-3);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 219, 130, 0.25);
      background: rgba(8, 16, 13, 0.68);
      padding: var(--space-3);
      color: var(--text-main);
    }

    .results h3 {
      margin-top: 0;
      color: var(--accent);
    }

    .results hr {
      border: none;
      border-top: 1px solid rgba(255, 218, 126, 0.2);
      margin: var(--space-2) 0;
    }

    #progress-wrap {
      margin-top: var(--space-2);
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.13);
      overflow: hidden;
    }

    #progress-bar {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #f2be4d, #ffe9a3);
      transition: width 0.16s linear;
    }

    .controls {
      margin: var(--space-3) 0;
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
    }

    .controls label {
      display: block;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-2);
      margin-top: var(--space-2);
    }

    .icm-hint {
      color: var(--text-dim);
      font-size: var(--font-2);
      margin: var(--space-2) 0;
    }

    .workspace-warning {
      display: none;
      margin: var(--space-2) 0;
      padding: 8px 10px;
      border: 1px solid rgba(255, 111, 111, 0.55);
      background: rgba(126, 28, 28, 0.45);
      color: var(--danger);
      border-radius: var(--radius-sm);
      font-size: var(--font-2);
      font-weight: 700;
    }

    .workspace-warning.active {
      display: block;
    }

    #icm-results,
    #trainer-panel,
    #settings-panel {
      margin-top: var(--space-3);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 222, 137, 0.22);
      background: rgba(8, 18, 14, 0.7);
      padding: var(--space-3);
    }

    #icm-results p {
      margin: var(--space-1) 0;
    }

    .icm-summary {
      padding: 2px 0;
    }

    #icm-details {
      margin-top: var(--space-2);
    }

    #icm-details summary {
      cursor: pointer;
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      background: rgba(255, 212, 105, 0.12);
      border: 1px solid rgba(255, 212, 105, 0.25);
      font-weight: 800;
      color: var(--accent);
      user-select: none;
    }

    #icm-details[open] summary {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    #icm-details .icm-details-body {
      background: rgba(4, 10, 8, 0.72);
      border: 1px solid rgba(255, 212, 105, 0.2);
      border-top: none;
      border-radius: 0 0 var(--radius-sm) var(--radius-sm);
      padding: var(--space-3);
    }

    #icm-error {
      display: none;
      margin-bottom: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border: 1px solid rgba(255, 127, 127, 0.5);
      background: rgba(98, 26, 26, 0.6);
      border-radius: var(--radius-sm);
      word-break: break-word;
      color: #ffcece;
      font-weight: 700;
    }

    #icm-error.active {
      display: block;
    }

    #assumed-ev {
      display: none;
      margin-top: var(--space-2);
      padding: var(--space-2);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(125, 228, 160, 0.35);
      background: rgba(20, 59, 34, 0.55);
      color: #d4f8df;
    }

    #assumed-ev.active {
      display: block;
    }

    .ev-positive {
      color: var(--ok);
      font-weight: 800;
    }

    .ev-negative {
      color: var(--danger);
      font-weight: 800;
    }

    #icm-breakdown {
      margin-top: var(--space-3);
      overflow-x: auto;
    }

    .icm-section-title {
      margin: var(--space-2) 0;
      color: var(--accent);
      font-weight: 900;
      font-size: var(--font-2);
    }

    .icm-table-container table,
    #icm-breakdown table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(11, 21, 17, 0.9);
    }

    .icm-table-container th,
    .icm-table-container td,
    #icm-breakdown th,
    #icm-breakdown td {
      border: 1px solid rgba(255, 218, 129, 0.22);
      padding: 7px 8px;
      font-size: 13px;
      text-align: left;
      white-space: nowrap;
      color: #f1f8f2;
    }

    .icm-table-container input,
    .icm-table-container select {
      min-width: 76px;
      margin-top: 0;
      font-size: 13px;
      padding: 6px 8px;
    }

    .icm-table-container input[readonly] {
      opacity: 0.78;
    }

    #icm-action-table th:last-child,
    #icm-action-table td:last-child {
      width: 1%;
      text-align: center;
    }

    #icm-action-table button {
      margin: 0;
      min-height: 32px;
      padding: 5px 10px;
      min-width: 0;
      font-size: 13px;
    }

    #icm-player-table tr.icm-player-hero td {
      background: rgba(61, 117, 176, 0.45);
    }

    #icm-player-table tr.icm-player-villain td {
      background: rgba(133, 102, 34, 0.5);
    }

    #icm-table-panel,
    #icm-drill-panel {
      margin-top: var(--space-3);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 222, 137, 0.22);
      background: rgba(8, 18, 14, 0.7);
      padding: var(--space-3);
    }

    #icm-table-visual {
      position: relative;
      min-height: 280px;
      border-radius: 999px;
      border: 2px solid rgba(255, 215, 120, 0.42);
      background:
        radial-gradient(circle at center, rgba(31, 94, 63, 0.6) 0%, rgba(15, 47, 31, 0.9) 66%, rgba(10, 28, 20, 0.95) 100%);
      overflow: hidden;
    }

    #icm-table-visual::before {
      content: '';
      position: absolute;
      inset: 12%;
      border: 1px dashed rgba(255, 231, 169, 0.3);
      border-radius: 999px;
      pointer-events: none;
    }

    .icm-seat {
      position: absolute;
      width: 132px;
      min-height: 84px;
      transform: translate(-50%, -50%);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 222, 137, 0.3);
      background: rgba(9, 18, 14, 0.88);
      padding: 7px 8px;
      font-size: 12px;
      color: #f1f8f2;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
    }

    .icm-seat.hero {
      border-color: rgba(125, 228, 160, 0.8);
      box-shadow: 0 10px 24px rgba(72, 182, 117, 0.35);
      background: rgba(16, 44, 30, 0.9);
    }

    .icm-seat.villain {
      border-color: rgba(255, 196, 107, 0.78);
      background: rgba(62, 45, 20, 0.85);
    }

    .icm-seat-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      font-weight: 800;
      color: var(--accent);
    }

    .icm-seat-role {
      color: var(--text-dim);
      font-size: 11px;
      font-weight: 700;
    }

    .icm-seat-stack {
      margin-top: 4px;
      font-weight: 700;
    }

    .icm-seat-hand {
      margin-top: 4px;
      font-size: 11px;
      color: #cce8d8;
      min-height: 14px;
    }

    .icm-seat-action {
      margin-top: 4px;
      font-size: 11px;
      color: #c4d4c8;
      min-height: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 430px) {
      #icm-table-visual {
        min-height: 280px;
      }

      .icm-seat {
        width: clamp(88px, 24vw, 108px);
        min-height: 70px;
        padding: 5px 6px;
        font-size: 10px;
      }

      .icm-seat-role,
      .icm-seat-stack,
      .icm-seat-hand,
      .icm-seat-action {
        font-size: 10px;
      }

      .icm-seat-action {
        white-space: normal;
        line-height: 1.15;
        max-height: 2.3em;
      }

      .icm-pos-badge {
        padding: 1px 5px;
        font-size: 9px;
      }
    }

    .icm-pos-badge {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 10px;
      font-weight: 900;
      border: 1px solid rgba(255, 230, 168, 0.34);
      color: #fbeab9;
      background: rgba(90, 68, 28, 0.42);
    }

    .icm-pos-btn {
      color: #162b20;
      background: rgba(255, 210, 101, 0.92);
      border-color: rgba(255, 218, 126, 0.95);
    }

    .icm-pos-sb {
      color: #122d36;
      background: rgba(137, 224, 255, 0.9);
      border-color: rgba(166, 236, 255, 0.95);
    }

    .icm-pos-bb {
      color: #1a1d36;
      background: rgba(163, 183, 255, 0.9);
      border-color: rgba(191, 205, 255, 0.95);
    }

    #icm-results.icm-drill-hidden {
      display: none;
    }

    #trainer-panel {
      display: grid;
      gap: var(--space-2);
    }

    .trainer-row {
      display: grid;
      gap: var(--space-2);
      grid-template-columns: 1fr;
    }

    #trainer-prompt {
      border: 1px solid rgba(255, 216, 123, 0.2);
      border-radius: var(--radius-sm);
      padding: var(--space-2) var(--space-3);
      background: rgba(7, 16, 13, 0.72);
      color: var(--text-soft);
    }

    #trainer-feedback {
      padding: var(--space-2) var(--space-3);
      border: 1px solid rgba(255, 216, 123, 0.2);
      border-radius: var(--radius-sm);
      background: rgba(7, 16, 13, 0.72);
      min-height: 56px;
    }

    #trainer-history {
      margin: 0;
      padding-left: 16px;
      max-height: 190px;
      overflow: auto;
      color: var(--text-soft);
      font-size: var(--font-2);
    }

    .scroll-hint {
      text-align: center;
      color: var(--text-dim);
      font-size: 11px;
      margin: 4px 0;
    }

    .hidden-mobile {
      display: none;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    #bottom-nav {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 80;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 1px;
      padding: 6px 8px calc(6px + env(safe-area-inset-bottom));
      background: rgba(6, 15, 12, 0.92);
      border-top: 1px solid rgba(255, 216, 123, 0.28);
      backdrop-filter: blur(8px);
    }

    #bottom-nav .nav-btn {
      margin: 0;
      min-height: 52px;
      border-radius: 12px;
      font-size: 10px;
      line-height: 1.15;
      border: 1px solid rgba(255, 222, 137, 0.2);
      background: rgba(27, 51, 38, 0.8);
      color: var(--text-soft);
      font-weight: 700;
      box-shadow: none;
    }

    #bottom-nav .nav-btn.active {
      color: #2a2010;
      border-color: rgba(255, 216, 123, 0.58);
      background:
        radial-gradient(circle at 30% 25%, rgba(255, 246, 213, 0.55), transparent 58%),
        linear-gradient(180deg, #ffd77f 0%, #f4be4a 100%);
    }

    #settings-panel .setting-row {
      display: grid;
      gap: var(--space-2);
    }

    @media (min-width: 768px) {
      body {
        padding: var(--space-5);
        padding-bottom: calc(var(--safe-bottom) + var(--space-5));
      }

      .container {
        padding: var(--space-5);
      }

      .button-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .range-save .inline-2 {
        grid-template-columns: 1fr auto auto;
      }

      .sample-select {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .ev-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .controls.controls-setup {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .controls.controls-action {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }

      .actions {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }

      .hud-main {
        grid-template-columns: 1.05fr 1fr 1fr;
      }

      #bottom-nav {
        left: 50%;
        transform: translateX(-50%);
        max-width: 680px;
        border-top-left-radius: 16px;
        border-top-right-radius: 16px;
        border-left: 1px solid rgba(255, 216, 123, 0.28);
        border-right: 1px solid rgba(255, 216, 123, 0.28);
      }

      .hidden-mobile {
        display: initial;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        transition-duration: 0ms !important;
        animation-duration: 0ms !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header class="app-header">
      <h1>Poker Equity Calculator</h1>
      <p class="section-label">モバイル最適化版: エクイティを判断に直結</p>
    </header>

    <!-- EV電卓タブ -->
    <div id="evcalc-tab" class="tab-content active">
      <section class="surface-card tight">
        <h2>EV電卓</h2>
        <p class="section-label">実戦用1アクション専用: 1ストリートのチップEVを即確認</p>
      </section>

      <section class="surface-card ev-block">
        <h3>MDF（最小防衛頻度）</h3>
        <p class="icm-hint ev-note">前提: 純ブラフ固定（コールされたら勝率0%）。相手はフォールド/コールのみ（レイズ/将来ストリート無視）。</p>
        <div class="ev-grid">
          <label for="evbet-pot">P (ベット前ポット)
            <input id="evbet-pot" type="number" min="0" step="0.1" placeholder="例: 10">
          </label>
          <label for="evbet-size">B (ベット額)
            <input id="evbet-size" type="number" min="0" step="0.1" placeholder="例: 6.7">
          </label>
        </div>
        <div class="ev-quick-bets">
          <button type="button" id="evbet-set-third" class="secondary">1/3P</button>
          <button type="button" id="evbet-set-half" class="secondary">1/2P</button>
          <button type="button" id="evbet-set-two-third" class="secondary">2/3P</button>
          <button type="button" id="evbet-set-pot" class="secondary">1.0P</button>
        </div>
        <div class="ev-out">
          最小防衛頻度（MDF）: <span id="evbet-mdf" class="ev-value">--</span><br>
          <span id="evbet-error" class="icm-hint"></span>
        </div>
        <div class="button-row">
          <button id="evcalc-calc-bet-btn" type="button" class="secondary">ベット更新</button>
        </div>
      </section>
    </div>

    <!-- エクイティ計算タブ -->
    <div id="winrate-tab" class="tab-content">
      <section class="surface-card tight">
        <h2>対想定レンジ</h2>
        <p class="section-label">レンジ対ハンドの勝率を算出</p>
      </section>
      <section id="equity-hud" aria-live="polite">
        <div class="hud-main">
          <div>
            <p class="hud-title">ヒーロー</p>
            <div id="hud-hero-cards">
              <span id="hud-hero-1" class="hud-card">--</span>
              <span id="hud-hero-2" class="hud-card">--</span>
            </div>
          </div>
          <div>
            <p class="hud-title">Villain Range</p>
            <div class="hud-number"><span id="hud-combos">0</span> / 1326</div>
            <div class="section-label"><span id="hud-combo-pct">0.0</span>% 有効コンボ</div>
          </div>
          <div>
            <p class="hud-title">Equity</p>
            <div class="hud-number" id="hud-equity-value">--%</div>
            <div id="hud-equity-error">誤差: --</div>
          </div>
        </div>
        <div id="hud-status-line">
          <span id="hud-status" class="status-neutral">待機中</span>
          <span id="hud-progress">進捗 0.0%</span>
        </div>
      </section>

      <section class="surface-card" id="card-selection">
        <h2>ヒーローのハンド</h2>
        <p class="section-label">タップして2枚選択</p>
        <div class="scroll-hint">カードグリッドは横スクロール可</div>
        <div class="card-grid-container">
          <table id="card-grid">
            <tr>
              <td data-card="As" class="black">A♠</td>
              <td data-card="Ks" class="black">K♠</td>
              <td data-card="Qs" class="black">Q♠</td>
              <td data-card="Js" class="black">J♠</td>
              <td data-card="Ts" class="black">T♠</td>
              <td data-card="9s" class="black">9♠</td>
              <td data-card="8s" class="black">8♠</td>
              <td data-card="7s" class="black">7♠</td>
              <td data-card="6s" class="black">6♠</td>
              <td data-card="5s" class="black">5♠</td>
              <td data-card="4s" class="black">4♠</td>
              <td data-card="3s" class="black">3♠</td>
              <td data-card="2s" class="black">2♠</td>
            </tr>
            <tr>
              <td data-card="Ah" class="red">A♥</td>
              <td data-card="Kh" class="red">K♥</td>
              <td data-card="Qh" class="red">Q♥</td>
              <td data-card="Jh" class="red">J♥</td>
              <td data-card="Th" class="red">T♥</td>
              <td data-card="9h" class="red">9♥</td>
              <td data-card="8h" class="red">8♥</td>
              <td data-card="7h" class="red">7♥</td>
              <td data-card="6h" class="red">6♥</td>
              <td data-card="5h" class="red">5♥</td>
              <td data-card="4h" class="red">4♥</td>
              <td data-card="3h" class="red">3♥</td>
              <td data-card="2h" class="red">2♥</td>
            </tr>
            <tr>
              <td data-card="Ad" class="red">A♦</td>
              <td data-card="Kd" class="red">K♦</td>
              <td data-card="Qd" class="red">Q♦</td>
              <td data-card="Jd" class="red">J♦</td>
              <td data-card="Td" class="red">T♦</td>
              <td data-card="9d" class="red">9♦</td>
              <td data-card="8d" class="red">8♦</td>
              <td data-card="7d" class="red">7♦</td>
              <td data-card="6d" class="red">6♦</td>
              <td data-card="5d" class="red">5♦</td>
              <td data-card="4d" class="red">4♦</td>
              <td data-card="3d" class="red">3♦</td>
              <td data-card="2d" class="red">2♦</td>
            </tr>
            <tr>
              <td data-card="Ac" class="black">A♣</td>
              <td data-card="Kc" class="black">K♣</td>
              <td data-card="Qc" class="black">Q♣</td>
              <td data-card="Jc" class="black">J♣</td>
              <td data-card="Tc" class="black">T♣</td>
              <td data-card="9c" class="black">9♣</td>
              <td data-card="8c" class="black">8♣</td>
              <td data-card="7c" class="black">7♣</td>
              <td data-card="6c" class="black">6♣</td>
              <td data-card="5c" class="black">5♣</td>
              <td data-card="4c" class="black">4♣</td>
              <td data-card="3c" class="black">3♣</td>
              <td data-card="2c" class="black">2♣</td>
            </tr>
          </table>
        </div>
        <div class="selection-display">
          選択中: <span id="hand-card1">--</span><span id="hand-card2">--</span><span id="hand-category"></span>
        </div>
      </section>

      <section class="surface-card" id="range-selection">
        <h2>相手のレンジ</h2>
        <div class="quick-ranges">
          <button type="button" onclick="selectRange('top5')">Top 5%</button>
          <button type="button" onclick="selectRange('top10')">Top 10%</button>
          <button type="button" onclick="selectRange('top15')">Top 15%</button>
          <button type="button" onclick="selectRange('top20')">Top 20%</button>
          <button type="button" onclick="selectRange('top30')">Top 30%</button>
          <button type="button" onclick="selectRange('pairs')">全ポケット</button>
          <button type="button" onclick="selectRange('broadway')">ブロードウェイ</button>
          <button type="button" onclick="selectRange('suited-connectors')">SC</button>
          <button type="button" onclick="selectRange('clear')" class="clear">クリア</button>
        </div>

        <div class="range-tools">
          <div class="range-zoom">
            <span class="chip-text">ズーム</span>
            <button type="button" id="zoom-sm-btn" class="small secondary">小</button>
            <button type="button" id="zoom-md-btn" class="small secondary">中</button>
            <button type="button" id="zoom-lg-btn" class="small secondary">大</button>
          </div>
        </div>

        <p class="section-label">セル長押し/ドラッグで連続選択対応</p>
        <div class="scroll-hint">レンジグリッドは横スクロール可</div>
        <div id="range-grid-container" class="range-grid-container zoom-md">
          <table id="range-grid">
            <!-- JavaScriptで生成 -->
          </table>
        </div>
        <div class="selection-display">
          169カテゴリ: <span id="range-count">0</span>/169 (<span id="range-percent">0.0</span>%)
        </div>

        <div class="range-save">
          <label for="range-name-input">レンジ名</label>
          <div class="inline-2">
            <input id="range-name-input" type="text" maxlength="40" placeholder="例: BTN open 30%">
            <button id="save-range-btn" type="button">保存</button>
          </div>
          <label for="saved-range-select">保存済みレンジ</label>
          <div class="inline-2">
            <select id="saved-range-select">
              <option value="">選択してください</option>
            </select>
            <button id="load-range-btn" type="button" class="secondary">読込</button>
            <button id="delete-range-btn" type="button" class="cancel">削除</button>
          </div>
          <label for="range-json-input">JSON入出力 (任意)</label>
          <input id="range-json-input" type="text" placeholder='{"name":"sample","hands":["AA","AKs"]}'>
          <div class="button-row">
            <button id="range-export-btn" type="button" class="secondary">JSON出力</button>
            <button id="range-import-btn" type="button" class="secondary">JSON読込</button>
          </div>
        </div>
      </section>

      <section class="surface-card tight">
        <div class="sample-select">
          <label for="calc-mode">計算モード
            <select id="calc-mode">
              <option value="precise" selected>精密 (全コンボ×サンプル)</option>
              <option value="fast">高速 (レンジ直接サンプル)</option>
            </select>
          </label>
          <label for="sample-count">サンプル数
            <select id="sample-count">
              <option value="25000">25,000回</option>
              <option value="50000">50,000回</option>
              <option value="100000">100,000回</option>
            </select>
          </label>
        </div>
        <p class="mode-note" id="calc-mode-note">精密: 広いレンジでは時間がかかります。高速: 推定値を素早く表示します。</p>
        <div class="selection-display" id="equity-precalc">
          相手有効コンボ数: <span id="villain-combo-count">0</span>
          / 推定総試行回数: <span id="estimated-trials">0</span>
        </div>
        <div id="progress-wrap" aria-hidden="true">
          <div id="progress-bar"></div>
        </div>
        <div class="button-row sticky-action-bar">
          <button id="calc-winrate-btn" type="button">エクイティ計算</button>
          <button id="cancel-winrate-btn" type="button" class="cancel" style="display:none;" disabled>キャンセル</button>
        </div>
      </section>

          <section class="surface-card">
            <p class="icm-hint">
              必要勝率（ポットオッズ）とコールEVは EV電卓 → 機能A を使用。<br>
              このタブはエクイティEの推定だけを行う。
            </p>
          </section>

      <div id="winrate-result" class="results"></div>
    </div>

    <!-- ICM計算タブ -->
    <div id="icm-tab" class="tab-content">
      <div class="controls controls-setup">
        <label>プレイヤー数
          <select id="num-players">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
          </select>
        </label>
        <label>BBアンティ
          <input type="number" id="bb-ante" step="0.1" min="0" placeholder="0">
        </label>
        <div class="actions">
          <button id="generate-btn" type="button">生成</button>
          <button id="jump-icm-table-btn" type="button" class="secondary">卓ビューへ移動</button>
        </div>
      </div>
      <p class="icm-hint">スタック/金額はBB換算。SB=0.5 / BB=1.0固定。2人ショーダウン前提。</p>

      <div id="player-inputs"></div>
      <div class="controls controls-action">
        <label>ヒーロー
          <select id="hero-index"></select>
        </label>
        <label>オールイン相手
          <select id="allin-index"></select>
        </label>
        <div class="icm-hint">想定勝率(%): <span id="assumed-winrate-display">--</span></div>
        <div class="icm-hint">ヒーロー: <span id="icm-assumed-hero-hand">--</span></div>
        <input type="hidden" id="assumed-winrate" value="">
      </div>
      <div id="assumed-sync-message" class="icm-hint status-neutral">想定勝率はプリフロップのエクイティ計算で更新されます。</div>

      <div id="icm-table-panel">
        <div class="icm-section-title">卓ビュー（ICM）</div>
        <div id="icm-table-visual" aria-live="polite"></div>
      </div>

      <div id="icm-drill-panel">
        <div class="icm-section-title">ICMドリル（方式1: プリフロップ想定勝率を使用）</div>
        <div id="icm-drill-prompt" class="icm-hint">想定勝率が未設定でも「出題」は可能です。回答判定はプリフロップ計算後に表示されます。</div>
        <div class="actions">
          <button id="icm-drill-start-btn" type="button">出題</button>
          <button id="icm-drill-call-btn" type="button" class="secondary">コール</button>
          <button id="icm-drill-fold-btn" type="button" class="secondary">フォールド</button>
        </div>
        <div id="icm-drill-feedback" class="icm-hint"></div>
      </div>

      <div id="icm-actions">
        <div class="icm-section-title">アクション(オールイン前)</div>
        <p class="icm-hint">オールイン相手はこの後自動オールインします。オールイン前アクションには追加しないでください（空欄でもOK）。</p>
        <p class="icm-hint">この欄は「オールイン前」のみです。オールイン後に行動する他プレイヤーは、このツールでは自動フォールド扱い（2人ショーダウン前提）されます。</p>
        <div class="icm-table-container">
          <table id="icm-action-table">
            <thead>
              <tr>
                <th>#</th>
                <th>プレイヤー</th>
                <th>アクション</th>
                <th>金額(to)</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="icm-action-rows"></tbody>
          </table>
        </div>
        <div class="actions">
          <button id="add-icm-action-btn" type="button">+ アクション追加</button>
          <button id="fold-others-icm-action-btn" type="button">残り全員フォールド</button>
          <button id="clear-icm-action-btn" type="button">クリア</button>
        </div>
      </div>
      <div class="actions">
        <button id="calc-icm-btn" type="button">ICM計算</button>
      </div>

      <div id="icm-results">
        <div id="icm-error" role="alert"></div>
        <div class="icm-summary">
          <p>有効オールイン(ヒーローvs相手): <span id="effective-stack">0.00</span></p>
          <p>相手オールイン(to): <span id="villain-allin-to">0.00</span></p>
          <p>コール額(追加): <span id="call-amount">0.00</span></p>
          <p>ショーダウンポット: <span id="pot-call">0.00</span></p>
          <p>必要勝率: <span id="required-winrate">0.00%</span> / エクイティ: <span id="equity-for-icm">-</span></p>
        </div>

        <details id="icm-details">
          <summary>詳細</summary>
          <div class="icm-details-body">
            <p>フォールド時 相手純増(デッドポット): <span id="pot-fold">0.00</span></p>
            <p>フォールド時 未コール返却(相手): <span id="fold-uncalled-villain">0.00</span></p>
            <p>コール時 未コール返却(相手): <span id="call-uncalled-villain">0.00</span></p>
            <p>フォールド時EV: <span id="fold-ev">0.00</span></p>
            <p>勝利時EV: <span id="win-ev">0.00</span></p>
            <p>敗北時EV: <span id="lose-ev">0.00</span></p>
            <div id="assumed-ev">
              <p>想定勝率でのコールEV: <span id="assumed-call-ev">0.00</span></p>
              <p>EV差(コール-フォールド): <span id="assumed-ev-diff">0.00</span></p>
            </div>
            <div id="icm-breakdown"></div>
            <div id="ev-list"></div>
          </div>
        </details>
      </div>

    </div>

    <div id="trainer-tab" class="tab-content">
      <div id="trainer-panel">
        <h2>トレーナー</h2>
        <p class="icm-hint">即答ドリル（MDF）。出題条件から正答を計算して答える。</p>
        <div id="trainer-prompt">「出題」を押して開始してください。</div>
        <div class="trainer-row">
          <label for="trainer-session-mode">進行モード
            <select id="trainer-session-mode">
              <option value="practice">練習（時間制限なし）</option>
              <option value="drill">鍛錬（時間制限あり）</option>
            </select>
          </label>
          <label for="trainer-time-limit-sec">制限秒数（鍛錬）
            <input id="trainer-time-limit-sec" type="number" min="1" step="1" value="8">
          </label>
          <label for="trainer-guess-input">あなたの回答(%)
            <input id="trainer-guess-input" type="number" min="0" max="100" step="0.1" placeholder="例: 33.3">
          </label>
          <div class="button-row">
            <button id="trainer-new-btn" type="button">出題</button>
            <button id="trainer-check-btn" type="button" class="secondary">答え合わせ</button>
          </div>
        </div>
        <div id="trainer-timer" class="icm-hint">残り時間: --</div>
        <div id="trainer-feedback"></div>
        <div id="trainer-stats">MDF平均得点: -- (0問)</div>
        <ol id="trainer-history"></ol>
      </div>
    </div>

	    <div id="settings-tab" class="tab-content">
	      <div id="settings-panel">
	        <h2>設定</h2>
	        <div class="setting-row">
	          <div class="icm-hint">
	            現在開いているURL: <span id="settings-current-url" class="icm-hint">--</span>
	          </div>
	          <div id="workspace-warning" class="workspace-warning" role="status" aria-live="polite"></div>
	        <label for="default-zoom-select">初期レンジズーム
            <select id="default-zoom-select">
              <option value="zoom-sm">小</option>
              <option value="zoom-md" selected>中</option>
              <option value="zoom-lg">大</option>
            </select>
          </label>
          <label for="default-mode-select">初期計算モード
            <select id="default-mode-select">
              <option value="precise" selected>精密</option>
              <option value="fast">高速</option>
            </select>
          </label>
	          <button id="save-settings-btn" type="button">設定を保存</button>
	        </div>
	        <div class="setting-row">
	          <button id="run-ev-selftest-btn" type="button" class="secondary">EV電卓セルフテスト</button>
	          <div id="ev-selftest-output" class="icm-hint">未実行</div>
	        </div>
	      </div>
	    </div>
  </div>

  <nav id="bottom-nav" aria-label="メインナビゲーション">
    <button type="button" class="nav-btn active" data-tab="evcalc-tab">EV電卓</button>
    <button type="button" class="nav-btn" data-tab="winrate-tab">プリフロップ</button>
    <button type="button" class="nav-btn" data-tab="icm-tab">ICM</button>
    <button type="button" class="nav-btn" data-tab="trainer-tab">トレーナー</button>
    <button type="button" class="nav-btn" data-tab="settings-tab">設定</button>
  </nav>

  <script>
		    // グローバル変数
		    let selectedCards = [];
		    let winrateCancelRequested = false;
		    let lastEquityPctForIcm = null;
		    let lastCalculatedEquity = null;
		    let lastEquityErrorPct = null;
		    let activeCalcMode = 'precise';
		    let isRangePointerDown = false;
		    let rangeDragMode = null;
		    let rangeSuppressClickUntil = 0;
		    let currentTrainerQuestion = null;
		    let trainerHistory = [];
		    let trainerTimerIntervalId = null;
		    let trainerQuestionStartedAtMs = null;
		    let trainerQuestionTimeoutAtMs = null;
		    let currentIcmDrillQuestion = null;
      let lastIcmDrillSpotType = null;

		    const SAVED_RANGES_KEY = 'poker_tool_saved_ranges_v1';
		    const TRAINER_HISTORY_KEY = 'poker_tool_trainer_history_v1';
		    const SETTINGS_KEY = 'poker_tool_settings_v1';
		    const TOTAL_HOLE_CARD_COMBOS = 1326;
		    const SAMPLE_OPTIONS_BY_MODE = {
		      precise: [5000, 10000, 25000],
		      fast: [0, 5000, 10000, 25000, 50000, 100000],
		    };
		    const FAST_ADAPTIVE_SAMPLE_SENTINEL = 0;
		    const FAST_ADAPTIVE_TARGET_MS = 450;
		    const FAST_ADAPTIVE_TARGET_ERROR_PCT = 2;
		    const FAST_ADAPTIVE_MIN_SAMPLES = 4000;
		    const FAST_ADAPTIVE_MAX_SAMPLES = 25000;
		    const FAST_CACHE_MAX_ENTRIES = 24;
		    const fastEquityCache = new Map();
		    const fastEquityCacheStats = { hits: 0, misses: 0, evictions: 0 };
		    const EVALUATOR_VARIANTS = ['legacy', 'h1', 'h2'];
		    const DEFAULT_EVALUATOR_VARIANT = 'h2';
		    let activeEvaluatorVariant = DEFAULT_EVALUATOR_VARIANT;
		    const EVAL_PROFILE_DEFAULT_SAMPLE_RATE = 64;
		    const SCORE_BASE = Math.pow(15, 5);
		    const ENCODE_POW_4 = Math.pow(15, 4);
		    const ENCODE_POW_3 = Math.pow(15, 3);
		    const ENCODE_POW_2 = Math.pow(15, 2);
		    const ENCODE_POW_1 = 15;
		    const HAND_CATEGORIES = [
      'AA','AKs','AQs','AJs','ATs','A9s','A8s','A7s','A6s','A5s','A4s','A3s','A2s',
      'AKo','KK','KQs','KJs','KTs','K9s','K8s','K7s','K6s','K5s','K4s','K3s','K2s',
      'AQo','KQo','QQ','QJs','QTs','Q9s','Q8s','Q7s','Q6s','Q5s','Q4s','Q3s','Q2s',
      'AJo','KJo','QJo','JJ','JTs','J9s','J8s','J7s','J6s','J5s','J4s','J3s','J2s',
      'ATo','KTo','QTo','JTo','TT','T9s','T8s','T7s','T6s','T5s','T4s','T3s','T2s',
      'A9o','K9o','Q9o','J9o','T9o','99','98s','97s','96s','95s','94s','93s','92s',
      'A8o','K8o','Q8o','J8o','T8o','98o','88','87s','86s','85s','84s','83s','82s',
      'A7o','K7o','Q7o','J7o','T7o','97o','87o','77','76s','75s','74s','73s','72s',
      'A6o','K6o','Q6o','J6o','T6o','96o','86o','76o','66','65s','64s','63s','62s',
      'A5o','K5o','Q5o','J5o','T5o','95o','85o','75o','65o','55','54s','53s','52s',
      'A4o','K4o','Q4o','J4o','T4o','94o','84o','74o','64o','54o','44','43s','42s',
      'A3o','K3o','Q3o','J3o','T3o','93o','83o','73o','63o','53o','43o','33','32s',
      'A2o','K2o','Q2o','J2o','T2o','92o','82o','72o','62o','52o','42o','32o','22'
    ];
    
    // カードランクとスート
    const ranks = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
    const suits = ['s', 'h', 'd', 'c'];
    const suitSymbols = { 's': '♠', 'h': '♥', 'd': '♦', 'c': '♣' };
    const RANK_VALUES = {
      'A':14, 'K':13, 'Q':12, 'J':11, 'T':10,
      '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2
    };
    
	    // デッキ作成
	    function createDeck() {
	      const deck = [];
	      for (const rank of ranks) {
        for (const suit of suits) {
          deck.push(rank + suit);
        }
      }
	      return deck;
	    }

		    const FULL_DECK = createDeck();
		    const CARD_ID_BY_TEXT = Object.create(null);
		    const CARD_TEXT_BY_ID = FULL_DECK.slice();
		    const CARD_RANK_BY_ID = new Uint8Array(FULL_DECK.length);
		    const CARD_SUIT_BY_ID = new Uint8Array(FULL_DECK.length);
		    const CARD_RANK_MASK_BY_ID = new Uint16Array(FULL_DECK.length);
		    const SUIT_INDEX_BY_CHAR = { s: 0, h: 1, d: 2, c: 3 };
		    const FULL_DECK_IDS = (() => {
		      const out = new Uint8Array(FULL_DECK.length);
		      for (let i = 0; i < FULL_DECK.length; i++) {
		        const card = FULL_DECK[i];
		        CARD_ID_BY_TEXT[card] = i;
		        const rank = RANK_VALUES[card[0]] || 0;
		        const suit = SUIT_INDEX_BY_CHAR[card[1]];
		        CARD_RANK_BY_ID[i] = rank;
		        CARD_SUIT_BY_ID[i] = Number.isFinite(suit) ? suit : 0;
		        CARD_RANK_MASK_BY_ID[i] = 1 << rank;
		        out[i] = i;
		      }
		      return out;
		    })();
		    const STRAIGHT_MASK_BY_HIGH = (() => {
		      const out = {};
		      for (let high = 14; high >= 5; high--) {
		        let mask = 0;
		        for (let r = high; r >= high - 4; r--) mask |= (1 << r);
		        out[high] = mask;
		      }
		      return out;
		    })();
		    const WHEEL_STRAIGHT_MASK = (1 << 14) | (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);

		    const CHEN_BASE = {
		      A: 10, K: 8, Q: 7, J: 6, T: 5,
		      9: 4.5, 8: 4, 7: 3.5, 6: 3, 5: 2.5, 4: 2, 3: 1.5, 2: 1,
		    };

		    const CATEGORY_COMBO_COUNT = (() => {
		      const out = {};
		      for (const cat of HAND_CATEGORIES) {
		        if (cat.length === 2) out[cat] = 6;
		        else if (cat.endsWith('s')) out[cat] = 4;
		        else out[cat] = 12;
		      }
		      return out;
		    })();

		    function getCategoryComboCount(handCategory) {
		      return CATEGORY_COMBO_COUNT[handCategory] || 0;
		    }

		    function scoreHandCategory(handCategory) {
		      if (!handCategory) return 0;
		      const r1 = handCategory[0];
		      const r2 = handCategory[1];
		      const isPair = handCategory.length === 2;
		      if (isPair) {
		        return CHEN_BASE[r1] * 2 + 5;
		      }
		      const hi = CHEN_BASE[r1] || 0;
		      const lo = CHEN_BASE[r2] || 0;
		      const i1 = ranks.indexOf(r1);
		      const i2 = ranks.indexOf(r2);
		      const gap = Math.max(0, Math.abs(i1 - i2) - 1);
		      let score = Math.max(hi, lo);
		      if (handCategory.endsWith('s')) score += 2;
		      if (gap === 1) score -= 1;
		      else if (gap === 2) score -= 2;
		      else if (gap === 3) score -= 4;
		      else if (gap >= 4) score -= 5;
		      if (Math.abs(i1 - i2) === 1 && hi < CHEN_BASE.A) score += 1;
		      return Math.max(0, score);
		    }

		    const CATEGORY_RANKING = HAND_CATEGORIES
		      .map((cat, idx) => ({ cat, idx, score: scoreHandCategory(cat), combos: getCategoryComboCount(cat) }))
		      .sort((a, b) => (b.score - a.score) || (b.combos - a.combos) || (a.idx - b.idx));

		    function readJsonFromStorage(key, fallback) {
		      try {
		        const raw = localStorage.getItem(key);
		        if (!raw) return fallback;
		        const parsed = JSON.parse(raw);
		        return parsed ?? fallback;
		      } catch (err) {
		        return fallback;
		      }
		    }

		    function writeJsonToStorage(key, value) {
		      try {
		        localStorage.setItem(key, JSON.stringify(value));
		      } catch (err) {
		        // ignore storage failure
		      }
		    }
    
    // 組み合わせを生成
    function* combinations(array, k) {
      if (k === 1) {
        for (const item of array) {
          yield [item];
        }
        return;
      }
      
      for (let i = 0; i <= array.length - k; i++) {
        const head = array[i];
        const tailCombos = combinations(array.slice(i + 1), k - 1);
        for (const combo of tailCombos) {
          yield [head, ...combo];
        }
      }
    }
    
	    function encodeScoreDigits(a = 0, b = 0, c = 0, d = 0, e = 0) {
	      return (
	        a * ENCODE_POW_4
	        + b * ENCODE_POW_3
	        + c * ENCODE_POW_2
	        + d * ENCODE_POW_1
	        + e
	      );
	    }

	    function getStraightHighFromMask(rankMask) {
	      for (let high = 14; high >= 5; high--) {
	        const need = STRAIGHT_MASK_BY_HIGH[high];
	        if ((rankMask & need) === need) return high;
	      }
	      if ((rankMask & WHEEL_STRAIGHT_MASK) === WHEEL_STRAIGHT_MASK) return 5;
	      return 0;
	    }

	    function normalizeEvaluatorVariant(variant) {
	      if (variant === 'legacy' || variant === 'h1' || variant === 'h2') return variant;
	      return DEFAULT_EVALUATOR_VARIANT;
	    }

	    function setEvaluatorVariant(variant) {
	      activeEvaluatorVariant = normalizeEvaluatorVariant(variant);
	      return activeEvaluatorVariant;
	    }

	    function getEvaluatorVariant() {
	      return normalizeEvaluatorVariant(activeEvaluatorVariant);
	    }

	    function cardTextToId(card) {
	      if (typeof card !== 'string') return -1;
	      const id = CARD_ID_BY_TEXT[card];
	      return Number.isFinite(id) ? id : -1;
	    }

	    function cardIdsToText(cardIds) {
	      const out = new Array(cardIds.length);
	      for (let i = 0; i < cardIds.length; i++) {
	        out[i] = CARD_TEXT_BY_ID[cardIds[i]];
	      }
	      return out;
	    }

	    function toCardIds(cards, outBuffer = null) {
	      const out = outBuffer && outBuffer.length >= cards.length ? outBuffer : new Int16Array(cards.length);
	      for (let i = 0; i < cards.length; i++) {
	        const id = cardTextToId(cards[i]);
	        if (id < 0) return null;
	        out[i] = id;
	      }
	      return out;
	    }

	    function createEvaluatorScratch() {
	      return {
	        rankCounts: new Uint8Array(15),
	        suitCounts: new Uint8Array(4),
	        suitMasks: new Uint16Array(4),
	      };
	    }

	    function resetEvaluatorScratch(scratch) {
	      scratch.rankCounts.fill(0);
	      scratch.suitCounts.fill(0);
	      scratch.suitMasks.fill(0);
	    }

	    // 5枚の役を評価 (旧評価器, 参照基準)
	    function evaluateFive(cards) {
	      const rankValues = cards.map(c => RANK_VALUES[c[0]]);
	      const suitValues = cards.map(c => c[1]);

	      const isFlush = new Set(suitValues).size === 1;

	      const rankCounts = {};
	      for (const r of rankValues) {
	        rankCounts[r] = (rankCounts[r] || 0) + 1;
	      }
	      const uniqueRanks = Object.keys(rankCounts).map(r => parseInt(r, 10)).sort((a, b) => b - a);

	      let isStraight = false;
	      let straightHigh = 0;
	      if (uniqueRanks.length === 5) {
	        if (uniqueRanks[0] - uniqueRanks[4] === 4) {
	          isStraight = true;
	          straightHigh = uniqueRanks[0];
	        } else if (
	          uniqueRanks[0] === 14
	          && uniqueRanks[1] === 5
	          && uniqueRanks[2] === 4
	          && uniqueRanks[3] === 3
	          && uniqueRanks[4] === 2
	        ) {
	          isStraight = true;
	          straightHigh = 5;
	        }
	      }

	      const groups = Object.entries(rankCounts).map(([rank, count]) => ({
	        rank: parseInt(rank, 10),
	        count,
	      }));
	      groups.sort((a, b) => (b.count - a.count) || (b.rank - a.rank));

	      if (isStraight && isFlush) {
	        return 8 * SCORE_BASE + encodeScoreDigits(straightHigh);
	      }
	      if (groups[0].count === 4) {
	        const quadRank = groups[0].rank;
	        const kicker = groups.find(g => g.count === 1).rank;
	        return 7 * SCORE_BASE + encodeScoreDigits(quadRank, kicker);
	      }
	      if (groups[0].count === 3 && groups[1].count === 2) {
	        return 6 * SCORE_BASE + encodeScoreDigits(groups[0].rank, groups[1].rank);
	      }
	      if (isFlush) {
	        const sorted = rankValues.slice().sort((a, b) => b - a);
	        return 5 * SCORE_BASE + encodeScoreDigits(sorted[0], sorted[1], sorted[2], sorted[3], sorted[4]);
	      }
	      if (isStraight) {
	        return 4 * SCORE_BASE + encodeScoreDigits(straightHigh);
	      }
	      if (groups[0].count === 3) {
	        const tripsRank = groups[0].rank;
	        const kickers = groups.filter(g => g.count === 1).map(g => g.rank).sort((a, b) => b - a);
	        return 3 * SCORE_BASE + encodeScoreDigits(tripsRank, kickers[0], kickers[1]);
	      }
	      if (groups[0].count === 2 && groups[1].count === 2) {
	        const pairRanks = groups.filter(g => g.count === 2).map(g => g.rank).sort((a, b) => b - a);
	        const kicker = groups.find(g => g.count === 1).rank;
	        return 2 * SCORE_BASE + encodeScoreDigits(pairRanks[0], pairRanks[1], kicker);
	      }
	      if (groups[0].count === 2) {
	        const pairRank = groups[0].rank;
	        const kickers = groups.filter(g => g.count === 1).map(g => g.rank).sort((a, b) => b - a);
	        return 1 * SCORE_BASE + encodeScoreDigits(pairRank, kickers[0], kickers[1], kickers[2]);
	      }

	      const sorted = rankValues.slice().sort((a, b) => b - a);
	      return encodeScoreDigits(sorted[0], sorted[1], sorted[2], sorted[3], sorted[4]);
	    }

	    const SEVEN_CHOOSE_FIVE_INDICES = (() => {
	      const combos = [];
	      for (let i = 0; i < 6; i++) {
	        for (let j = i + 1; j < 7; j++) {
	          const five = [];
	          for (let k = 0; k < 7; k++) {
	            if (k !== i && k !== j) five.push(k);
	          }
	          combos.push(five);
	        }
	      }
	      return combos;
	    })();

	    // 旧評価器: 7C5=21 を固定で評価
	    function evaluateLegacy(cards) {
	      if (cards.length === 7) {
	        let best = 0;
	        const fiveCards = new Array(5);
	        for (const idxs of SEVEN_CHOOSE_FIVE_INDICES) {
	          fiveCards[0] = cards[idxs[0]];
	          fiveCards[1] = cards[idxs[1]];
	          fiveCards[2] = cards[idxs[2]];
	          fiveCards[3] = cards[idxs[3]];
	          fiveCards[4] = cards[idxs[4]];
	          const score = evaluateFive(fiveCards);
	          if (score > best) best = score;
	        }
	        return best;
	      }

	      let best = 0;
	      for (const five of combinations(cards, 5)) {
	        const score = evaluateFive(five);
	        if (score > best) best = score;
	      }
	      return best;
	    }

	    function evaluate7FastFromIds(cardIds, scratch = null) {
	      if (!cardIds || cardIds.length !== 7) return 0;
	      const s = scratch || createEvaluatorScratch();
	      resetEvaluatorScratch(s);
	      const rankCounts = s.rankCounts;
	      const suitCounts = s.suitCounts;
	      const suitMasks = s.suitMasks;
	      let rankMask = 0;

	      for (let i = 0; i < 7; i++) {
	        const cardId = cardIds[i];
	        const rank = CARD_RANK_BY_ID[cardId];
	        const suit = CARD_SUIT_BY_ID[cardId];
	        rankCounts[rank]++;
	        suitCounts[suit]++;
	        suitMasks[suit] |= CARD_RANK_MASK_BY_ID[cardId];
	        rankMask |= CARD_RANK_MASK_BY_ID[cardId];
	      }

	      let straightFlushHigh = 0;
	      for (let suit = 0; suit < 4; suit++) {
	        if (suitCounts[suit] < 5) continue;
	        const high = getStraightHighFromMask(suitMasks[suit]);
	        if (high > straightFlushHigh) straightFlushHigh = high;
	      }
	      if (straightFlushHigh > 0) return 8 * SCORE_BASE + encodeScoreDigits(straightFlushHigh);

	      let quadRank = 0;
	      for (let rank = 14; rank >= 2; rank--) {
	        if (rankCounts[rank] === 4) {
	          quadRank = rank;
	          break;
	        }
	      }
	      if (quadRank > 0) {
	        let kicker = 0;
	        for (let rank = 14; rank >= 2; rank--) {
	          if (rank !== quadRank && rankCounts[rank] > 0) {
	            kicker = rank;
	            break;
	          }
	        }
	        return 7 * SCORE_BASE + encodeScoreDigits(quadRank, kicker);
	      }

	      let topTrip = 0;
	      let secondTrip = 0;
	      let topPair = 0;
	      for (let rank = 14; rank >= 2; rank--) {
	        const cnt = rankCounts[rank];
	        if (cnt >= 3) {
	          if (topTrip === 0) topTrip = rank;
	          else if (secondTrip === 0) secondTrip = rank;
	        } else if (cnt >= 2 && topPair === 0) {
	          topPair = rank;
	        }
	      }
	      if (topTrip > 0 && (secondTrip > 0 || topPair > 0)) {
	        return 6 * SCORE_BASE + encodeScoreDigits(topTrip, secondTrip || topPair);
	      }

	      let bestFlushScore = 0;
	      for (let suit = 0; suit < 4; suit++) {
	        if (suitCounts[suit] < 5) continue;
	        const mask = suitMasks[suit];
	        let picked = 0;
	        let r1 = 0;
	        let r2 = 0;
	        let r3 = 0;
	        let r4 = 0;
	        let r5 = 0;
	        for (let rank = 14; rank >= 2 && picked < 5; rank--) {
	          if ((mask & (1 << rank)) === 0) continue;
	          if (picked === 0) r1 = rank;
	          else if (picked === 1) r2 = rank;
	          else if (picked === 2) r3 = rank;
	          else if (picked === 3) r4 = rank;
	          else r5 = rank;
	          picked++;
	        }
	        if (picked === 5) {
	          const score = 5 * SCORE_BASE + encodeScoreDigits(r1, r2, r3, r4, r5);
	          if (score > bestFlushScore) bestFlushScore = score;
	        }
	      }
	      if (bestFlushScore > 0) return bestFlushScore;

	      const straightHigh = getStraightHighFromMask(rankMask);
	      if (straightHigh > 0) return 4 * SCORE_BASE + encodeScoreDigits(straightHigh);

	      if (topTrip > 0) {
	        let k1 = 0;
	        let k2 = 0;
	        for (let rank = 14; rank >= 2; rank--) {
	          if (rank === topTrip || rankCounts[rank] === 0) continue;
	          if (k1 === 0) k1 = rank;
	          else {
	            k2 = rank;
	            break;
	          }
	        }
	        return 3 * SCORE_BASE + encodeScoreDigits(topTrip, k1, k2);
	      }

	      let pair1 = 0;
	      let pair2 = 0;
	      for (let rank = 14; rank >= 2; rank--) {
	        if (rankCounts[rank] < 2) continue;
	        if (pair1 === 0) pair1 = rank;
	        else {
	          pair2 = rank;
	          break;
	        }
	      }
	      if (pair2 > 0) {
	        let kicker = 0;
	        for (let rank = 14; rank >= 2; rank--) {
	          if (rank !== pair1 && rank !== pair2 && rankCounts[rank] > 0) {
	            kicker = rank;
	            break;
	          }
	        }
	        return 2 * SCORE_BASE + encodeScoreDigits(pair1, pair2, kicker);
	      }

	      if (pair1 > 0) {
	        let k1 = 0;
	        let k2 = 0;
	        let k3 = 0;
	        for (let rank = 14; rank >= 2; rank--) {
	          if (rank === pair1 || rankCounts[rank] === 0) continue;
	          if (k1 === 0) k1 = rank;
	          else if (k2 === 0) k2 = rank;
	          else {
	            k3 = rank;
	            break;
	          }
	        }
	        return 1 * SCORE_BASE + encodeScoreDigits(pair1, k1, k2, k3);
	      }

	      let r1 = 0;
	      let r2 = 0;
	      let r3 = 0;
	      let r4 = 0;
	      let r5 = 0;
	      let picked = 0;
	      for (let rank = 14; rank >= 2 && picked < 5; rank--) {
	        if (rankCounts[rank] === 0) continue;
	        if (picked === 0) r1 = rank;
	        else if (picked === 1) r2 = rank;
	        else if (picked === 2) r3 = rank;
	        else if (picked === 3) r4 = rank;
	        else r5 = rank;
	        picked++;
	      }
	      return encodeScoreDigits(r1, r2, r3, r4, r5);
	    }

	    const EVALUATE_TEMP_CARD_IDS = new Int16Array(7);
	    const EVALUATE_TEMP_SCRATCH = createEvaluatorScratch();

	    function evaluate7Fast(cards) {
	      if (!cards || cards.length !== 7) return evaluateLegacy(cards);
	      if (typeof cards[0] === 'number') {
	        return evaluate7FastFromIds(cards, EVALUATE_TEMP_SCRATCH);
	      }
	      const ids = toCardIds(cards, EVALUATE_TEMP_CARD_IDS);
	      if (!ids) return evaluateLegacy(cards);
	      return evaluate7FastFromIds(ids, EVALUATE_TEMP_SCRATCH);
	    }

	    function evaluate(cards, options = null) {
	      const variant = normalizeEvaluatorVariant(options?.variant || activeEvaluatorVariant);
	      if (variant === 'legacy') return evaluateLegacy(cards);
	      return evaluate7Fast(cards);
	    }

	    function seededRandomFactory(seed) {
	      let t = (seed >>> 0) || 1;
	      return function next() {
	        t += 0x6D2B79F5;
	        let x = Math.imul(t ^ (t >>> 15), 1 | t);
	        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
	        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
	      };
	    }

	    function runEvaluatorMismatchProbe(opts = null) {
	      const options = opts || {};
	      const trials = Number.isFinite(options.trials) ? Math.max(1, Math.floor(options.trials)) : 50000;
	      const seed = Number.isFinite(options.seed) ? (options.seed >>> 0) : 20260226;
	      const random = seededRandomFactory(seed);
	      const source = new Int16Array(FULL_DECK_IDS.length);
	      const work = new Int16Array(FULL_DECK_IDS.length);
	      const draw = new Int16Array(7);
	      const drawCards = new Array(7);
	      const h2Scratch = createEvaluatorScratch();
	      let mismatchH1 = 0;
	      let mismatchH2 = 0;
	      const mismatchSamples = [];
	      const startedAt = performance.now();

	      for (let i = 0; i < FULL_DECK_IDS.length; i++) source[i] = FULL_DECK_IDS[i];
	      for (let n = 0; n < trials; n++) {
	        work.set(source);
	        for (let i = 0; i < 7; i++) {
	          const j = i + Math.floor(random() * (work.length - i));
	          const tmp = work[i];
	          work[i] = work[j];
	          work[j] = tmp;
	          draw[i] = work[i];
	          drawCards[i] = CARD_TEXT_BY_ID[draw[i]];
	        }

	        const legacy = evaluateLegacy(drawCards);
	        const h1 = evaluate7Fast(drawCards);
	        const h2 = evaluate7FastFromIds(draw, h2Scratch);
	        if (legacy !== h1) {
	          mismatchH1++;
	          if (mismatchSamples.length < 5) {
	            mismatchSamples.push({
	              hand: drawCards.slice(),
	              legacy,
	              h1,
	              h2,
	            });
	          }
	        }
	        if (legacy !== h2) {
	          mismatchH2++;
	          if (mismatchSamples.length < 5) {
	            mismatchSamples.push({
	              hand: drawCards.slice(),
	              legacy,
	              h1,
	              h2,
	            });
	          }
	        }
	      }

	      return {
	        trials,
	        seed,
	        mismatchH1,
	        mismatchH2,
	        mismatchTotal: mismatchH1 + mismatchH2,
	        mismatchSamples,
	        elapsedMs: performance.now() - startedAt,
	      };
	    }
    
	    function randomInt(maxExclusive) {
	      return Math.floor(Math.random() * maxExclusive);
	    }

	    // デッキ配列から重複なしで5枚を引く（配列生成なし、引いた後にデッキ順序を復元）
	    function drawBoardFromDeck(deck, outBoard, swapIndices) {
	      const len = deck.length;
	      for (let i = 0; i < 5; i++) {
	        const j = i + randomInt(len - i);
	        swapIndices[i] = j;
	        const tmp = deck[i];
	        deck[i] = deck[j];
	        deck[j] = tmp;
	        outBoard[i] = deck[i];
	      }

	      for (let i = 4; i >= 0; i--) {
	        const j = swapIndices[i];
	        const tmp = deck[i];
	        deck[i] = deck[j];
	        deck[j] = tmp;
	      }
	    }

	    function nextFrame() {
	      return new Promise(resolve => setTimeout(resolve, 0));
	    }

	    function setProgressBar(progressPct) {
	      const bar = document.getElementById('progress-bar');
	      if (!bar) return;
	      const pct = Math.max(0, Math.min(100, progressPct || 0));
	      bar.style.width = pct.toFixed(1) + '%';
	    }

	    function setHudStatus(text, cls = 'status-neutral') {
	      const hud = document.getElementById('hud-status');
	      if (!hud) return;
	      hud.className = cls;
	      hud.textContent = text;
	    }

	    function setHudProgress(progressPct) {
	      const el = document.getElementById('hud-progress');
	      if (!el) return;
	      const pct = Math.max(0, Math.min(100, progressPct || 0));
	      el.textContent = `進捗 ${pct.toFixed(1)}%`;
	      setProgressBar(pct);
	    }

	    function setHudEquityValue(equityPct, errorPct) {
	      const equityEl = document.getElementById('hud-equity-value');
	      const errorEl = document.getElementById('hud-equity-error');
	      if (equityEl) {
	        equityEl.textContent = Number.isFinite(equityPct) ? `${equityPct.toFixed(2)}%` : '--%';
	      }
	      if (errorEl) {
	        errorEl.textContent = Number.isFinite(errorPct) ? `誤差: ±${errorPct.toFixed(2)}%` : '誤差: --';
	      }
	    }

	    function setHudHeroCards() {
	      const targets = [
	        document.getElementById('hud-hero-1'),
	        document.getElementById('hud-hero-2'),
	      ];
	      for (let i = 0; i < 2; i++) {
	        const card = selectedCards[i];
	        const target = targets[i];
	        if (!target) continue;
	        if (!card) {
	          target.textContent = '--';
	          target.className = 'hud-card';
	          continue;
	        }
	        target.textContent = card[0] + suitSymbols[card[1]];
	        target.className = 'hud-card ' + ((card[1] === 'h' || card[1] === 'd') ? 'red' : '');
	      }
	    }

	    function setHudComboStats(combosCount) {
	      const combosEl = document.getElementById('hud-combos');
	      const pctEl = document.getElementById('hud-combo-pct');
	      const combos = Math.max(0, combosCount || 0);
	      if (combosEl) combosEl.textContent = combos.toLocaleString();
	      if (pctEl) pctEl.textContent = ((combos / TOTAL_HOLE_CARD_COMBOS) * 100).toFixed(1);
	    }

	    function getSelectedRangeCells() {
	      return Array.from(document.querySelectorAll('#range-grid td.active-range'));
	    }

	    function getSelectedRangeCategories() {
	      return getSelectedRangeCells().map(cell => cell.dataset.hand).filter(Boolean);
	    }

	    function clearComputedEquityDisplays() {
      lastCalculatedEquity = null;
      lastEquityErrorPct = null;
      setHudEquityValue(null, null);
      setHudStatus('待機中', 'status-neutral');
      setHudProgress(0);
      const resultDiv = document.getElementById('winrate-result');
      if (resultDiv) resultDiv.innerHTML = '';
    }

    function readNumeric(id) {
	      const el = document.getElementById(id);
	      if (!el) return null;
	      const str = el.value.trim();
	      if (str === '') return null;
	      const n = parseFloat(str);
	      return Number.isFinite(n) ? n : null;
	    }

	    function formatSignedNumber(value, digits) {
	      if (!Number.isFinite(value)) return '--';
	      const sign = value >= 0 ? '+' : '';
	      return `${sign}${value.toFixed(digits)}`;
	    }

	    function calcCallEv(pAfter, call, returned, equity) {
	      const pShow = pAfter + call - returned;
	      const req = call / pShow;
	      const ev = equity * pShow - call;
	      return { pShow, req, ev };
	    }

	    function calcBetEv(pot, bet, foldRate) {
	      // 純ブラフ固定（コールされたら勝率0%）:
	      // calledEV = -B
	      // EV_bluff = F*P + (1-F)*(-B) = F*(P+B) - B
	      // F_be = B/(P+B), MDF = P/(P+B)
	      const calledEv = -bet;
	      const ev = foldRate * pot + (1 - foldRate) * calledEv;
	      const den = pot + bet;
	      if (!Number.isFinite(den) || den <= 0) {
	        return { calledEv, ev, fBe: null, mdf: null, fBeIndeterminate: true };
	      }
	      const fBe = bet / den;
	      const mdf = pot / den;
	      return { calledEv, ev, fBe, mdf, fBeIndeterminate: false };
	    }

	    function setDecisionSign(signEl, isPositive, positiveLabel, negativeLabel) {
	      signEl.classList.remove('status-neutral', 'status-positive', 'status-negative');
	      if (isPositive) {
	        signEl.classList.add('status-positive');
	        signEl.textContent = positiveLabel;
	      } else {
	        signEl.classList.add('status-negative');
	        signEl.textContent = negativeLabel;
	      }
	    }

	    function updateCallEvDecision() {
      const pAfter = readNumeric('evcall-pot-after');
      const call = readNumeric('evcall-cost');
      let returned = readNumeric('evcall-uncalled');
      const equityPct = readNumeric('evcall-equity');
      const pAfterInput = document.getElementById('evcall-pot-after');
      const callInput = document.getElementById('evcall-cost');

      const reqEl = document.getElementById('evcall-req');
      const evEl = document.getElementById('evcall-ev');
      const gapEl = document.getElementById('evcall-gap');
      const signEl = document.getElementById('evcall-sign');
      const errEl = document.getElementById('evcall-error');
      if (!reqEl || !evEl || !gapEl || !signEl || !errEl) return;

      reqEl.textContent = '--';
      evEl.textContent = '--';
      gapEl.textContent = '--';
      signEl.className = 'status-neutral';
      signEl.textContent = '未入力';
      errEl.textContent = '';
      evEl.classList.remove('ev-positive', 'ev-negative');
      gapEl.classList.remove('ev-positive', 'ev-negative');

      if (pAfter === null || call === null) {
        errEl.textContent = 'ポット額とコール額を入力';
        if (pAfter === null && pAfterInput) pAfterInput.focus();
        else if (call === null && callInput) callInput.focus();
        return;
      }
	      if (returned === null) returned = 0;
	      if (pAfter < 0 || call < 0 || returned < 0 || returned > pAfter) {
	        errEl.textContent = '入力エラー: ポット額>=0, コール額>=0, 0<=未マッチ返却<=ポット額';
	        return;
	      }

	      const pEff = pAfter - returned;
	      if (pEff < 0) {
	        errEl.textContent = '入力エラー: ポット額-未マッチ返却 が負です';
	        return;
	      }
	      const pShow = pAfter + call - returned;
	      if (pShow <= 0) {
	        errEl.textContent = '入力エラー: 合計ポット（ポット額+コール額-未マッチ返却）は正である必要があります';
	        return;
	      }

      const req = calcCallEv(pAfter, call, returned, 0).req;
      reqEl.textContent = `${(req * 100).toFixed(2)}%`;

      if (equityPct === null) {
        evEl.textContent = '--';
        gapEl.textContent = '--';
        return;
      }
      if (equityPct < 0 || equityPct > 100) {
        errEl.textContent = '入力エラー: 0<=勝率<=100';
        return;
      }

      const e = equityPct / 100;
      const callCalc = calcCallEv(pAfter, call, returned, e);
      const ev = callCalc.ev;
      const gap = equityPct - req * 100;

      evEl.textContent = formatSignedNumber(ev, 3);
      gapEl.textContent = `${formatSignedNumber(gap, 2)}pt`;
      evEl.classList.add(ev >= 0 ? 'ev-positive' : 'ev-negative');
      gapEl.classList.add(gap >= 0 ? 'ev-positive' : 'ev-negative');
      setDecisionSign(signEl, ev >= 0, 'コール +EV', 'コール -EV');
    }

	    function updateBetEvDecision() {
	      const pot = readNumeric('evbet-pot');
	      const bet = readNumeric('evbet-size');
      const potInput = document.getElementById('evbet-pot');
      const betInput = document.getElementById('evbet-size');

      const mdfEl = document.getElementById('evbet-mdf');
	      const errEl = document.getElementById('evbet-error');
	      if (!mdfEl || !errEl) return;

      mdfEl.textContent = '--';
	      errEl.textContent = '';

	      if (pot === null || bet === null) {
        errEl.textContent = 'P と B を入力';
        if (pot === null && potInput) potInput.focus();
        else if (bet === null && betInput) betInput.focus();
        return;
      }
      if (pot < 0 || bet <= 0) {
        errEl.textContent = '入力エラー: P>=0, B>0';
        return;
      }

	      // 純ブラフ固定(コール時勝率0%): MDF = P/(P+B)
	      const betCalc = calcBetEv(pot, bet, 0);
      const mdf = betCalc.mdf;
      if (betCalc.fBeIndeterminate || !Number.isFinite(mdf)) {
        errEl.textContent = '入力エラー: MDF の計算結果が不正です';
        return;
      }
      mdfEl.textContent = `${(mdf * 100).toFixed(2)}%`;
	    }

	    function setEvBetByPotRatio(ratio) {
	      const potInput = document.getElementById('evbet-pot');
	      const pot = readNumeric('evbet-pot');
	      const errEl = document.getElementById('evbet-error');
      if (!Number.isFinite(pot) || pot < 0) {
        if (errEl) errEl.textContent = '先にPを入力';
        if (potInput) potInput.focus();
        return;
      }
	      const betInput = document.getElementById('evbet-size');
	      if (!betInput) return;
	      betInput.value = (pot * ratio).toFixed(2);
	    }

	    function runEvCalculatorSelfTests() {
	      const outputEl = document.getElementById('ev-selftest-output');
	      if (!outputEl) return;

	      const pctTol = 1e-4;
	      const evTol = 1e-6;
	      const rows = [];
	      let passCount = 0;

	      const addCheck = (name, actual, expected, tol, unit = '') => {
	        const ok = Number.isFinite(actual) && Math.abs(actual - expected) <= tol;
	        if (ok) passCount++;
	        rows.push({
	          name,
	          ok,
	          actual,
	          expected,
	          unit,
	        });
	      };

	      const a1 = calcCallEv(10, 5, 0, 1 / 3);
	      addCheck('CALL1 req', a1.req * 100, 100 / 3, pctTol, '%');
	      addCheck('CALL1 EV', a1.ev, 0, evTol);

	      const a2 = calcCallEv(10, 5, 0, 0.5);
	      addCheck('CALL2 EV', a2.ev, 2.5, evTol);

	      const a3 = calcCallEv(10, 3, 2, 3 / 11);
	      addCheck('CALL3 req', a3.req * 100, (3 / 11) * 100, pctTol, '%');
	      addCheck('CALL3 EV', a3.ev, 0, evTol);

	      const a4 = calcCallEv(8, 2, 1, 0);
	      addCheck('CALL4 req', a4.req * 100, (2 / 9) * 100, pctTol, '%');

	      const b1 = calcBetEv(10, 5, 1 / 3);
	      addCheck('B1 F_be', (b1.fBe ?? NaN) * 100, 100 / 3, pctTol, '%');
      addCheck('B1 MDF', (b1.mdf ?? NaN) * 100, (2 / 3) * 100, pctTol, '%');
	      addCheck('B1 EV', b1.ev, 0, evTol);

	      const b2 = calcBetEv(10, 5, 0.5);
	      addCheck('B2 EV', b2.ev, 2.5, evTol);

	      const b3 = calcBetEv(10, 5, 0);
	      addCheck('B3 F_be', (b3.fBe ?? NaN) * 100, 100 / 3, pctTol, '%');

	      const b4 = calcBetEv(0, 5, 0);
	      addCheck('B4 F_be', (b4.fBe ?? NaN) * 100, 100, pctTol, '%');

	      const b5 = calcBetEv(12, 3, 0);
	      addCheck('B5 MDF', (b5.mdf ?? NaN) * 100, 80, pctTol, '%');

	      const total = rows.length;
	      const failCount = total - passCount;
	      const lines = rows.map(r => {
	        const mark = r.ok ? 'PASS' : 'FAIL';
	        const actual = Number.isFinite(r.actual) ? r.actual.toFixed(4) : 'NaN';
	        const expected = Number.isFinite(r.expected) ? r.expected.toFixed(4) : 'NaN';
	        return `${mark} ${r.name}: actual=${actual}${r.unit} expected=${expected}${r.unit}`;
	      });

	      outputEl.innerHTML = `セルフテスト: ${passCount}/${total} PASS` + (failCount ? ` / ${failCount} FAIL` : '') + `<br>${lines.join('<br>')}`;
	      outputEl.classList.remove('status-positive', 'status-negative', 'status-neutral');
      outputEl.classList.add(failCount === 0 ? 'status-positive' : 'status-negative');
      }

	    function renderSampleOptions(mode, preferredValue = null) {
		      const select = document.getElementById('sample-count');
		      if (!select) return;
		      const options = SAMPLE_OPTIONS_BY_MODE[mode] || SAMPLE_OPTIONS_BY_MODE.precise;
	      const current = preferredValue ?? parseInt(select.value, 10);
	      select.innerHTML = '';
		      options.forEach((value, idx) => {
		        const opt = document.createElement('option');
		        opt.value = String(value);
			        if (mode === 'precise') {
			          const labels = ['標準', '高精度', '最高精度'];
			          opt.textContent = `${value.toLocaleString()}回/コンボ (${labels[idx] || ''})`;
			        } else {
			          if (value === FAST_ADAPTIVE_SAMPLE_SENTINEL) {
			            opt.textContent = `AUTO (${FAST_ADAPTIVE_TARGET_MS}ms目標 / 誤差±${FAST_ADAPTIVE_TARGET_ERROR_PCT.toFixed(1)}% / ${FAST_ADAPTIVE_MIN_SAMPLES.toLocaleString()}〜${FAST_ADAPTIVE_MAX_SAMPLES.toLocaleString()}試行)`;
			          } else {
			            const labels = ['最速', '高速', '標準', '高精度', '超高精度'];
			            const label = labels[Math.max(0, idx - 1)] || '';
			            opt.textContent = `${value.toLocaleString()}試行 (${label})`;
		          }
		        }
		        select.appendChild(opt);
		      });
	      if (Number.isFinite(current) && options.includes(current)) {
	        select.value = String(current);
	      } else {
	        select.value = String(options[Math.min(1, options.length - 1)]);
	      }
	    }

	    function applyCalcMode(mode, keepSample = false) {
	      const normalized = mode === 'fast' ? 'fast' : 'precise';
	      activeCalcMode = normalized;
	      const modeSelect = document.getElementById('calc-mode');
	      if (modeSelect) modeSelect.value = normalized;
	      const defaultModeSelect = document.getElementById('default-mode-select');
	      if (defaultModeSelect) defaultModeSelect.value = normalized;
	      renderSampleOptions(normalized, keepSample ? parseInt(document.getElementById('sample-count')?.value, 10) : null);
		      const note = document.getElementById('calc-mode-note');
			      if (note) {
			        note.textContent = normalized === 'fast'
			          ? `高速: AUTO(${FAST_ADAPTIVE_TARGET_MS}ms目標 / 誤差±${FAST_ADAPTIVE_TARGET_ERROR_PCT.toFixed(1)}%) と固定試行を切り替え、体感テンポを優先できます。`
			          : '精密: 全コンボごとにサンプルを回すため、広いレンジでは時間がかかります。';
			      }
	      updateEquityPrecalcDisplay();
	    }

	    function applyRangeZoomClass(zoomClass) {
	      const container = document.getElementById('range-grid-container');
	      if (!container) return;
	      const normalized = ['zoom-sm', 'zoom-md', 'zoom-lg'].includes(zoomClass) ? zoomClass : 'zoom-md';
	      container.classList.remove('zoom-sm', 'zoom-md', 'zoom-lg');
	      container.classList.add(normalized);
	      const states = {
	        'zoom-sm-btn': normalized === 'zoom-sm',
	        'zoom-md-btn': normalized === 'zoom-md',
	        'zoom-lg-btn': normalized === 'zoom-lg',
	      };
	      Object.entries(states).forEach(([id, isOn]) => {
	        const btn = document.getElementById(id);
	        if (!btn) return;
	        btn.setAttribute('aria-pressed', isOn ? 'true' : 'false');
	      });
	      const select = document.getElementById('default-zoom-select');
	      if (select) select.value = normalized;
	    }

	    function readAppSettings() {
	      const fallback = { zoom: 'zoom-md', mode: 'precise' };
	      const raw = readJsonFromStorage(SETTINGS_KEY, fallback);
	      return {
	        zoom: ['zoom-sm', 'zoom-md', 'zoom-lg'].includes(raw.zoom) ? raw.zoom : fallback.zoom,
	        mode: raw.mode === 'fast' ? 'fast' : 'precise',
	      };
	    }

	    function hasStoredAppSettings() {
	      try {
	        return !!localStorage.getItem(SETTINGS_KEY);
	      } catch (err) {
	        return false;
	      }
	    }

	    function saveAppSettings() {
	      const zoomSelect = document.getElementById('default-zoom-select');
	      const modeSelect = document.getElementById('default-mode-select');
	      const settings = {
	        zoom: zoomSelect ? zoomSelect.value : 'zoom-md',
	        mode: modeSelect && modeSelect.value === 'fast' ? 'fast' : 'precise',
	      };
	      writeJsonToStorage(SETTINGS_KEY, settings);
	    }

	    function switchTab(tabId) {
	      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
	      document.querySelectorAll('#bottom-nav .nav-btn').forEach(b => b.classList.remove('active'));
	      const tab = document.getElementById(tabId);
	      if (tab) tab.classList.add('active');
	      const navBtn = document.querySelector(`#bottom-nav .nav-btn[data-tab="${tabId}"]`);
	      if (navBtn) navBtn.classList.add('active');
      if (tabId === 'icm-tab') {
        requestAnimationFrame(() => {
          renderIcmTableVisual();
          const visualEl = document.getElementById('icm-table-visual');
          const seatCount = visualEl ? visualEl.querySelectorAll('.icm-seat').length : 0;
          console.info(`[ICM_TAB_OPEN] seats=${seatCount}`);
        });
      }
	    }

	    function getTopPercentCategories(percent) {
	      const capped = Math.max(0, Math.min(100, percent));
	      const targetCombos = TOTAL_HOLE_CARD_COMBOS * (capped / 100);
	      const selected = [];
	      let running = 0;
	      for (const entry of CATEGORY_RANKING) {
	        selected.push(entry.cat);
	        running += entry.combos;
	        if (running >= targetCombos) break;
	      }
	      return selected;
	    }
    
    // レンジグリッドの生成
    function generateRangeGrid() {
      const rangeGrid = document.getElementById('range-grid');
      const rangeLayout = [
        ['AA','AKs','AQs','AJs','ATs','A9s','A8s','A7s','A6s','A5s','A4s','A3s','A2s'],
        ['AKo','KK','KQs','KJs','KTs','K9s','K8s','K7s','K6s','K5s','K4s','K3s','K2s'],
        ['AQo','KQo','QQ','QJs','QTs','Q9s','Q8s','Q7s','Q6s','Q5s','Q4s','Q3s','Q2s'],
        ['AJo','KJo','QJo','JJ','JTs','J9s','J8s','J7s','J6s','J5s','J4s','J3s','J2s'],
        ['ATo','KTo','QTo','JTo','TT','T9s','T8s','T7s','T6s','T5s','T4s','T3s','T2s'],
        ['A9o','K9o','Q9o','J9o','T9o','99','98s','97s','96s','95s','94s','93s','92s'],
        ['A8o','K8o','Q8o','J8o','T8o','98o','88','87s','86s','85s','84s','83s','82s'],
        ['A7o','K7o','Q7o','J7o','T7o','97o','87o','77','76s','75s','74s','73s','72s'],
        ['A6o','K6o','Q6o','J6o','T6o','96o','86o','76o','66','65s','64s','63s','62s'],
        ['A5o','K5o','Q5o','J5o','T5o','95o','85o','75o','65o','55','54s','53s','52s'],
        ['A4o','K4o','Q4o','J4o','T4o','94o','84o','74o','64o','54o','44','43s','42s'],
        ['A3o','K3o','Q3o','J3o','T3o','93o','83o','73o','63o','53o','43o','33','32s'],
        ['A2o','K2o','Q2o','J2o','T2o','92o','82o','72o','62o','52o','42o','32o','22']
      ];
      
      rangeLayout.forEach((row, i) => {
        const tr = document.createElement('tr');
        row.forEach((hand, j) => {
          const td = document.createElement('td');
          td.textContent = hand;
          const catIndex = HAND_CATEGORIES.indexOf(hand);
          td.dataset.cat = catIndex;
          td.dataset.hand = hand;
          
          // スタイルクラス
          if (hand[0] === hand[1]) {
            td.classList.add('pair');
          } else if (hand.endsWith('s')) {
            td.classList.add('suited');
          } else {
            td.classList.add('offsuit');
          }
          
          tr.appendChild(td);
        });
        rangeGrid.appendChild(tr);
      });
    }
    
    // カード選択処理
    function handleCardClick(e) {
      const cell = e.currentTarget;
      const card = cell.dataset.card;
	      if (cell.classList.contains('disabled') && !cell.classList.contains('selected')) {
	        return;
	      }
      
      const idx = selectedCards.indexOf(card);
      
      if (idx !== -1) {
        // 選択解除
        selectedCards.splice(idx, 1);
        cell.classList.remove('selected');
      } else {
        if (selectedCards.length === 2) {
          // 既に2枚選択されている場合、最初のカードを解除
          const firstCard = selectedCards.shift();
          document.querySelector(`[data-card="${firstCard}"]`).classList.remove('selected');
        }
        
        // 新しいカードを選択
        selectedCards.push(card);
        cell.classList.add('selected');
      }
      
      updateHandDisplay();
    }
    
    // ハンド表示更新
		    function updateHandDisplay() {
		      clearEquityForIcmDisplay();
		      const card1Display = document.getElementById('hand-card1');
		      const card2Display = document.getElementById('hand-card2');
		      const categoryDisplay = document.getElementById('hand-category');
      
      if (selectedCards[0]) {
        const rank = selectedCards[0][0];
        const suit = selectedCards[0][1];
        card1Display.innerHTML = rank + suitSymbols[suit];
        card1Display.className = (suit === 'h' || suit === 'd') ? 'red' : 'black';
      } else {
        card1Display.textContent = '--';
        card1Display.className = '';
      }
      
      if (selectedCards[1]) {
        const rank = selectedCards[1][0];
        const suit = selectedCards[1][1];
        card2Display.innerHTML = rank + suitSymbols[suit];
        card2Display.className = (suit === 'h' || suit === 'd') ? 'red' : 'black';
      } else {
        card2Display.textContent = '--';
        card2Display.className = '';
      }
      
      // カードの有効/無効表示
      document.querySelectorAll('#card-grid td').forEach(cardCell => {
        cardCell.classList.remove('disabled');
        if (selectedCards.length === 2 && !selectedCards.includes(cardCell.dataset.card)) {
          cardCell.classList.add('disabled');
        }
      });

      // カテゴリー表示とヒーローハンド強調
      document.querySelectorAll('#range-grid td').forEach(cell => {
        cell.classList.remove('hero-hand');
      });
      
      if (selectedCards.length === 2) {
        const category = getHandCategory(selectedCards[0], selectedCards[1]);
        categoryDisplay.textContent = `(${category})`;
        const catId = HAND_CATEGORIES.indexOf(category);
        if (catId !== -1) {
          const cell = document.querySelector(`#range-grid td[data-cat="${catId}"]`);
          if (cell) {
            cell.classList.add('hero-hand');
          }
        }
	      } else {
	        categoryDisplay.textContent = '';
	      }
	      setHudHeroCards();
	      updateEquityPrecalcDisplay();
	    }
    
    // カードからカテゴリーを取得
    function getHandCategory(card1, card2) {
      const rank1 = card1[0];
      const rank2 = card2[0];
      const suit1 = card1[1];
      const suit2 = card2[1];
      
      const rankIndex1 = ranks.indexOf(rank1);
      const rankIndex2 = ranks.indexOf(rank2);
      
      // ポケットペア
      if (rank1 === rank2) {
        return rank1 + rank1;
      }
      
      // 高い方を先に
      const [highRank, lowRank] = rankIndex1 < rankIndex2 ? [rank1, rank2] : [rank2, rank1];
      
      // スーテッドかオフスート
      const suited = suit1 === suit2;
      return highRank + lowRank + (suited ? 's' : 'o');
    }
    
    // レンジ選択処理
    function handleRangeClick(e) {
      const cell = e.currentTarget;
      if (!cell) return;
      cell.classList.toggle('active-range');
      updateRangeDisplay();
    }

    function updateRangeCountDisplay() {
      const selectedCells = getSelectedRangeCells();
      const count = selectedCells.length;
      const percent = (count / 169 * 100).toFixed(1);
      document.getElementById('range-count').textContent = String(count);
      document.getElementById('range-percent').textContent = percent;
    }

    // レンジ表示更新
		    function updateRangeDisplay() {
		      clearEquityForIcmDisplay();
		      updateRangeCountDisplay();
		      updateEquityPrecalcDisplay();
		    }

		    function updateEquityPrecalcDisplay() {
		      const villainComboSpan = document.getElementById('villain-combo-count');
		      const estimatedTrialsSpan = document.getElementById('estimated-trials');
		      if (!villainComboSpan || !estimatedTrialsSpan) return;

	      const villainCells = getSelectedRangeCells();
	      const blockedCards = selectedCards.length === 2 ? selectedCards : [];
	      let combosCount = 0;
	      for (const cell of villainCells) {
	        const handCategory = cell.dataset.hand;
	        if (!handCategory) continue;
	        combosCount += getCombosForHand(handCategory, blockedCards).length;
	      }
	      villainComboSpan.textContent = String(combosCount);
	      setHudComboStats(combosCount);

		      const sampleCount = parseInt(document.getElementById('sample-count')?.value, 10);
		      const mode = document.getElementById('calc-mode')?.value === 'fast' ? 'fast' : 'precise';
		      if (mode === 'fast' && sampleCount === FAST_ADAPTIVE_SAMPLE_SENTINEL) {
		        estimatedTrialsSpan.textContent = `${FAST_ADAPTIVE_MIN_SAMPLES.toLocaleString()}〜${FAST_ADAPTIVE_MAX_SAMPLES.toLocaleString()} (AUTO)`;
		      } else {
		        const trials = Number.isFinite(sampleCount) ? (mode === 'fast' ? sampleCount : combosCount * sampleCount) : 0;
			        estimatedTrialsSpan.textContent = trials.toLocaleString();
		      }
			    }

				    function clearEquityForIcmDisplay() {
				      lastEquityPctForIcm = null;
				      const span = document.getElementById('equity-for-icm');
				      if (span) span.textContent = '-';
				      setAssumedWinrateFromPreflop(null, null);
				      clearComputedEquityDisplays();
				    }

				    function setEquityForIcmDisplay(equityPct) {
				      if (!Number.isFinite(equityPct)) return;
				      lastEquityPctForIcm = equityPct;
				      const span = document.getElementById('equity-for-icm');
				      if (!span) return;
				      span.textContent = equityPct.toFixed(2) + '%';
				    }

				    function setAssumedSyncMessage(message, toneClass = '') {
				      const msgEl = document.getElementById('assumed-sync-message');
				      if (!msgEl) return;
				      msgEl.textContent = message;
				      msgEl.classList.remove('status-positive', 'status-negative', 'status-neutral');
				      if (toneClass) msgEl.classList.add(toneClass);
				    }

				    function readAssumedWinratePct() {
				      const hiddenInput = document.getElementById('assumed-winrate');
				      if (!hiddenInput) return null;
				      const str = hiddenInput.value.trim();
				      if (str === '') return null;
				      const pct = parseFloat(str);
				      if (!Number.isFinite(pct) || pct < 0 || pct > 100) return null;
				      return pct;
				    }

				    function setAssumedWinrateFromPreflop(equityPct, heroCards = null) {
				      const hiddenInput = document.getElementById('assumed-winrate');
				      const display = document.getElementById('assumed-winrate-display');
				      const heroHandEl = document.getElementById('icm-assumed-hero-hand');
				      if (!hiddenInput || !display || !heroHandEl) return false;

				      if (!Number.isFinite(equityPct)) {
				        hiddenInput.value = '';
				        display.textContent = '--';
				        heroHandEl.textContent = '--';
				        setAssumedSyncMessage('想定勝率はプリフロップのエクイティ計算で更新されます。', 'status-neutral');
				        updateAssumedEvDisplay();
				        renderIcmTableVisual();
				        resetIcmDrillQuestion();
				        return true;
				      }

				      const boundedPct = Math.max(0, Math.min(100, equityPct));
				      hiddenInput.value = boundedPct.toFixed(2);
				      display.textContent = `${boundedPct.toFixed(2)}%`;
				      const heroText = Array.isArray(heroCards) && heroCards.length === 2 ? `${heroCards[0]}${heroCards[1]}` : '--';
				      heroHandEl.textContent = heroText;
				      setAssumedSyncMessage(`プリフロップ計算結果を反映: 想定勝率 ${boundedPct.toFixed(2)}%`, 'status-positive');
				      updateAssumedEvDisplay();
				      renderIcmTableVisual();
				      resetIcmDrillQuestion('想定勝率を更新しました。「出題」でICMドリルを開始してください。');
				      return true;
				    }

		    function setCalculatedEquity(equityPct, errorPct) {
	      lastCalculatedEquity = equityPct;
	      lastEquityErrorPct = errorPct;
	      setHudEquityValue(equityPct, errorPct);
	      setEquityForIcmDisplay(equityPct);
	      setAssumedWinrateFromPreflop(equityPct, selectedCards);
	    }

    function applyRangeCategories(categories) {
	      const set = new Set(categories);
	      document.querySelectorAll('#range-grid td').forEach(td => {
	        td.classList.toggle('active-range', set.has(td.dataset.hand));
	      });
	      updateRangeDisplay();
	    }

	    function readBroadwayCategories() {
	      const broadwaySet = new Set(['A', 'K', 'Q', 'J', 'T']);
	      return HAND_CATEGORIES.filter(cat => {
	        if (cat.length === 2) return broadwaySet.has(cat[0]);
	        return broadwaySet.has(cat[0]) && broadwaySet.has(cat[1]);
	      });
	    }

	    function readSuitedConnectorCategories() {
	      return HAND_CATEGORIES.filter(cat => {
	        if (!cat.endsWith('s')) return false;
	        const a = ranks.indexOf(cat[0]);
	        const b = ranks.indexOf(cat[1]);
	        return Math.abs(a - b) === 1;
	      });
	    }

	    // プリセットレンジ選択
	    function selectRange(type) {
	      const normalized = String(type || '').toLowerCase();
	      if (normalized === 'clear') {
	        applyRangeCategories([]);
	        return;
	      }
	      if (normalized.startsWith('top')) {
	        const pct = parseInt(normalized.replace('top', ''), 10);
	        if (Number.isFinite(pct)) {
	          applyRangeCategories(getTopPercentCategories(pct));
	          return;
	        }
	      }
	      if (normalized === 'pairs') {
	        applyRangeCategories(HAND_CATEGORIES.filter(cat => cat.length === 2));
	        return;
	      }
	      if (normalized === 'broadway') {
	        applyRangeCategories(readBroadwayCategories());
	        return;
	      }
	      if (normalized === 'suited-connectors') {
	        applyRangeCategories(readSuitedConnectorCategories());
	        return;
	      }
	      applyRangeCategories([]);
	    }

	    function setupRangePointerInteractions() {
	      const table = document.getElementById('range-grid');
	      if (!table) return;

	      table.addEventListener('pointerdown', (e) => {
	        const cell = e.target.closest('#range-grid td');
	        if (!cell) return;
	        if (e.pointerType === 'mouse' && e.button !== 0) return;
	        e.preventDefault();
	        rangeSuppressClickUntil = performance.now() + 400;
	        isRangePointerDown = true;
	        rangeDragMode = !cell.classList.contains('active-range');
	        cell.classList.toggle('active-range', rangeDragMode);
	        cell.classList.add('dragging-target');
	        updateRangeCountDisplay();
	      });

	      table.addEventListener('pointerover', (e) => {
	        if (!isRangePointerDown) return;
	        const cell = e.target.closest('#range-grid td');
	        if (!cell || cell.classList.contains('dragging-target')) return;
	        cell.classList.add('dragging-target');
	        cell.classList.toggle('active-range', rangeDragMode);
	        updateRangeCountDisplay();
	      });

	      const stopDrag = () => {
	        if (!isRangePointerDown) return;
	        isRangePointerDown = false;
	        rangeDragMode = null;
	        document.querySelectorAll('#range-grid td.dragging-target').forEach(td => td.classList.remove('dragging-target'));
	        updateRangeDisplay();
	      };
	      window.addEventListener('pointerup', stopDrag);
	      window.addEventListener('pointercancel', stopDrag);
	    }

	    function getSavedRanges() {
	      const raw = readJsonFromStorage(SAVED_RANGES_KEY, []);
	      if (!Array.isArray(raw)) return [];
	      const validHands = new Set(HAND_CATEGORIES);
	      return raw
	        .map(item => {
	          const name = String(item?.name || '').trim();
	          const hands = Array.isArray(item?.hands) ? item.hands.filter(h => validHands.has(h)) : [];
	          if (!name || hands.length === 0) return null;
	          return { name, hands: Array.from(new Set(hands)) };
	        })
	        .filter(Boolean);
	    }

	    function saveRanges(ranges) {
	      writeJsonToStorage(SAVED_RANGES_KEY, ranges);
	    }

	    function refreshSavedRangeOptions(selectedName = '') {
	      const select = document.getElementById('saved-range-select');
	      if (!select) return;
	      const prev = selectedName || select.value;
	      const ranges = getSavedRanges();
	      select.innerHTML = '<option value="">選択してください</option>';
	      ranges.forEach(range => {
	        const opt = document.createElement('option');
	        opt.value = range.name;
	        opt.textContent = `${range.name} (${range.hands.length}カテゴリ)`;
	        select.appendChild(opt);
	      });
	      if (prev && ranges.some(r => r.name === prev)) {
	        select.value = prev;
	      }
	    }

	    function jumpToIcmTablePanel(reason = 'manual') {
	      const panel = document.getElementById('icm-table-panel');
	      if (!panel) {
	        setIcmError('卓ビュー要素が見つかりません。ページ再読み込み後に再実行してください');
	        return;
	      }
	      switchTab('icm-tab');
	      requestAnimationFrame(() => {
	        panel.scrollIntoView({ behavior: 'auto', block: 'start' });
	        const visualEl = document.getElementById('icm-table-visual');
	        const seatCount = visualEl ? visualEl.querySelectorAll('.icm-seat').length : 0;
	        const top = Math.round(panel.getBoundingClientRect().top);
	        console.info(`[ICM_PANEL_JUMP] reason=${reason} top=${top} seats=${seatCount}`);
	      });
	    }

	    function saveCurrentRange() {
	      const nameInput = document.getElementById('range-name-input');
	      const name = String(nameInput?.value || '').trim();
	      if (!name) {
	        window.alert('レンジ名を入力してください。');
	        return;
	      }
	      const hands = getSelectedRangeCategories();
	      if (hands.length === 0) {
	        window.alert('保存するレンジが空です。');
	        return;
	      }
	      const ranges = getSavedRanges();
	      const next = ranges.filter(r => r.name !== name);
	      next.push({ name, hands });
	      saveRanges(next);
	      refreshSavedRangeOptions(name);
	    }

	    function loadSelectedRange() {
	      const select = document.getElementById('saved-range-select');
	      if (!select || !select.value) return;
	      const range = getSavedRanges().find(r => r.name === select.value);
	      if (!range) return;
	      applyRangeCategories(range.hands);
	      const nameInput = document.getElementById('range-name-input');
	      if (nameInput) nameInput.value = range.name;
	    }

	    function deleteSelectedRange() {
	      const select = document.getElementById('saved-range-select');
	      if (!select || !select.value) return;
	      const targetName = select.value;
	      const next = getSavedRanges().filter(r => r.name !== targetName);
	      saveRanges(next);
	      refreshSavedRangeOptions('');
	    }

	    function exportRangeJson() {
	      const input = document.getElementById('range-json-input');
	      if (!input) return;
	      const select = document.getElementById('saved-range-select');
	      const selectedName = select?.value || '';
	      const selected = selectedName ? getSavedRanges().find(r => r.name === selectedName) : null;
	      const nameField = document.getElementById('range-name-input');
	      const payload = selected || {
	        name: String(nameField?.value || 'range').trim() || 'range',
	        hands: getSelectedRangeCategories(),
	      };
	      input.value = JSON.stringify(payload);
	    }

	    function importRangeJson() {
	      const input = document.getElementById('range-json-input');
	      if (!input) return;
	      const raw = input.value.trim();
	      if (!raw) {
	        window.alert('JSONが空です。');
	        return;
	      }
	      try {
	        const parsed = JSON.parse(raw);
	        const name = String(parsed?.name || '').trim();
	        const hands = Array.isArray(parsed?.hands) ? parsed.hands.filter(h => HAND_CATEGORIES.includes(h)) : [];
	        if (!name || hands.length === 0) {
	          window.alert('JSON形式が不正です。name と hands[] を確認してください。');
	          return;
	        }
	        const ranges = getSavedRanges().filter(r => r.name !== name);
	        ranges.push({ name, hands: Array.from(new Set(hands)) });
	        saveRanges(ranges);
	        refreshSavedRangeOptions(name);
	        applyRangeCategories(hands);
	        const nameInput = document.getElementById('range-name-input');
	        if (nameInput) nameInput.value = name;
	      } catch (err) {
	        window.alert('JSONの解析に失敗しました。');
	      }
	    }
	    
	    // 組み合わせを取得（ブロッカー考慮）
	    function getCombosForHand(handCategory, blockedCards) {
	      const combos = [];
	      
	      if (handCategory.length === 2 && handCategory[0] === handCategory[1]) {
	        // ポケットペア
	        const rank = handCategory[0];
	        const rankCards = FULL_DECK.filter(c => c[0] === rank && !blockedCards.includes(c));
	        for (const combo of combinations(rankCards, 2)) {
	          combos.push(combo);
	        }
      } else if (handCategory.endsWith('s')) {
        // スーテッド
        const r1 = handCategory[0];
        const r2 = handCategory[1];
        for (const suit of suits) {
          const c1 = r1 + suit;
          const c2 = r2 + suit;
          if (!blockedCards.includes(c1) && !blockedCards.includes(c2)) {
            combos.push([c1, c2]);
          }
        }
      } else if (handCategory.endsWith('o')) {
        // オフスート
        const r1 = handCategory[0];
        const r2 = handCategory[1];
        for (const s1 of suits) {
          for (const s2 of suits) {
            if (s1 !== s2) {
              const c1 = r1 + s1;
              const c2 = r2 + s2;
              if (!blockedCards.includes(c1) && !blockedCards.includes(c2)) {
                combos.push([c1, c2]);
              }
            }
          }
        }
      }
      
	      return combos;
	    }

	    function resolveFastSamplePlan(sampleCount) {
	      if (!Number.isFinite(sampleCount) || sampleCount < 0) return null;
		      if (sampleCount === FAST_ADAPTIVE_SAMPLE_SENTINEL) {
		        return {
		          kind: 'adaptive',
		          targetMs: FAST_ADAPTIVE_TARGET_MS,
		          targetErrorPct: FAST_ADAPTIVE_TARGET_ERROR_PCT,
		          minSamples: FAST_ADAPTIVE_MIN_SAMPLES,
		          maxSamples: FAST_ADAPTIVE_MAX_SAMPLES,
		        };
		      }
		      return {
		        kind: 'fixed',
		        targetMs: null,
		        targetErrorPct: null,
		        minSamples: sampleCount,
		        maxSamples: sampleCount,
		      };
		    }

	    function buildFastEquityCacheKey(heroCards, rangeCategories, samplePlan, evaluatorVariant = null) {
	      if (!Array.isArray(heroCards) || heroCards.length !== 2) return null;
	      if (!Array.isArray(rangeCategories) || rangeCategories.length === 0) return null;
	      if (!samplePlan || !samplePlan.kind) return null;
	      const heroKey = heroCards.slice().sort().join(',');
	      const rangeKey = Array.from(new Set(rangeCategories.filter(Boolean))).sort().join(',');
		      const planKey = samplePlan.kind === 'adaptive'
		        ? `adaptive:${samplePlan.targetMs}:${samplePlan.targetErrorPct}:${samplePlan.minSamples}:${samplePlan.maxSamples}`
		        : `fixed:${samplePlan.maxSamples}`;
	      const variantKey = normalizeEvaluatorVariant(evaluatorVariant || activeEvaluatorVariant);
	      return `v1|hero=${heroKey}|range=${rangeKey}|plan=${planKey}|eval=${variantKey}`;
	    }

	    function readFastEquityCache(cacheKey) {
	      if (!cacheKey || !fastEquityCache.has(cacheKey)) {
	        fastEquityCacheStats.misses++;
	        return null;
	      }
	      const cached = fastEquityCache.get(cacheKey);
	      fastEquityCache.delete(cacheKey);
	      fastEquityCache.set(cacheKey, cached);
	      fastEquityCacheStats.hits++;
	      return cached;
	    }

	    function writeFastEquityCache(cacheKey, payload) {
	      if (!cacheKey || !payload) return;
	      if (fastEquityCache.has(cacheKey)) {
	        fastEquityCache.delete(cacheKey);
	      }
	      fastEquityCache.set(cacheKey, payload);
	      while (fastEquityCache.size > FAST_CACHE_MAX_ENTRIES) {
	        const oldestKey = fastEquityCache.keys().next().value;
	        fastEquityCache.delete(oldestKey);
	        fastEquityCacheStats.evictions++;
	      }
	    }

		    function getFastEquityCacheStats() {
		      return {
		        hits: fastEquityCacheStats.hits,
		        misses: fastEquityCacheStats.misses,
		        evictions: fastEquityCacheStats.evictions,
		        size: fastEquityCache.size,
		      };
		    }

		    function calculateMonteCarloStats(totalWins, totalTies, totalTrials) {
		      const totalOutcome = totalWins + totalTies * 0.5;
		      const equity = totalTrials > 0 ? (totalOutcome / totalTrials) * 100 : 0;
		      const meanOutcome = totalTrials > 0 ? (totalOutcome / totalTrials) : 0;
		      const secondMoment = totalTrials > 0 ? ((totalWins + totalTies * 0.25) / totalTrials) : 0;
		      const variance = Math.max(0, secondMoment - meanOutcome * meanOutcome);
		      const stderr = totalTrials > 0 ? Math.sqrt(variance / totalTrials) : 0;
		      const errorPct = stderr * 1.96 * 100;
		      return { equity, errorPct, variance, stderr };
		    }

		    function getAdaptiveStopReasonLabel(stopReason) {
		      if (stopReason === 'error_budget') return '誤差予算';
		      if (stopReason === 'time_budget') return '時間予算';
		      if (stopReason === 'max_samples') return '上限試行';
		      if (stopReason === 'fixed_samples') return '固定試行';
		      if (stopReason === 'canceled') return 'キャンセル';
		      return '不明';
		    }

		    function createHotspotProfile(sampleRate = EVAL_PROFILE_DEFAULT_SAMPLE_RATE) {
		      const normalized = Number.isFinite(sampleRate) && sampleRate > 0 ? Math.max(1, Math.floor(sampleRate)) : EVAL_PROFILE_DEFAULT_SAMPLE_RATE;
		      return {
		        enabled: true,
		        sampleRate: normalized,
		        sampled: 0,
		        drawMs: 0,
		        evalMs: 0,
		        loopMs: 0,
		      };
		    }

		    function toHotspotBreakdown(profile, totalTrials) {
		      if (!profile || !profile.enabled || profile.sampled <= 0 || totalTrials <= 0) return null;
		      const sampledTotal = profile.loopMs;
		      const sampledOther = Math.max(0, sampledTotal - profile.drawMs - profile.evalMs);
		      const drawShare = sampledTotal > 0 ? profile.drawMs / sampledTotal : 0;
		      const evalShare = sampledTotal > 0 ? profile.evalMs / sampledTotal : 0;
		      const otherShare = sampledTotal > 0 ? sampledOther / sampledTotal : 0;
		      return {
		        sampleRate: profile.sampleRate,
		        sampledTrials: profile.sampled,
		        sampledMs: {
		          total: sampledTotal,
		          draw: profile.drawMs,
		          evaluate: profile.evalMs,
		          other: sampledOther,
		        },
		        sampledShare: {
		          draw: drawShare,
		          evaluate: evalShare,
		          other: otherShare,
		        },
		        estimatedMs: {
		          draw: drawShare * profile.loopMs * (totalTrials / profile.sampled),
		          evaluate: evalShare * profile.loopMs * (totalTrials / profile.sampled),
		          other: otherShare * profile.loopMs * (totalTrials / profile.sampled),
		        },
		      };
		    }

		    function buildRemainingDeckByVillainIds(heroCardIds, villainComboIds) {
		      if (!heroCardIds || heroCardIds.length !== 2 || !Array.isArray(villainComboIds)) return [];
		      const h0 = heroCardIds[0];
		      const h1 = heroCardIds[1];
		      return villainComboIds.map((villainCardIds) => {
		        const v0 = villainCardIds?.[0];
		        const v1 = villainCardIds?.[1];
		        const deck = new Uint8Array(48);
		        let ptr = 0;
		        for (let cardId = 0; cardId < FULL_DECK_IDS.length; cardId++) {
		          if (cardId === h0 || cardId === h1 || cardId === v0 || cardId === v1) continue;
		          deck[ptr++] = cardId;
		        }
		        return deck;
		      });
		    }

		    function buildRemainingDeckByVillain(heroCards, villainCombos) {
		      if (!Array.isArray(heroCards) || heroCards.length !== 2 || !Array.isArray(villainCombos)) return [];
		      const [h0, h1] = heroCards;
		      return villainCombos.map((villainCards) => {
		        const v0 = villainCards?.[0];
		        const v1 = villainCards?.[1];
		        const deck = [];
		        for (const card of FULL_DECK) {
		          if (card === h0 || card === h1 || card === v0 || card === v1) continue;
		          deck.push(card);
		        }
		        return deck;
		      });
		    }

	    async function runFastEquityMonteCarlo(heroCards, allVillainCombos, samplePlan, onProgress = null, shouldCancel = null, runtimeOptions = null) {
	      if (!samplePlan) return null;
	      const options = runtimeOptions || {};
	      const evaluatorVariant = normalizeEvaluatorVariant(options.evaluatorVariant || activeEvaluatorVariant);
	      const useIntPath = evaluatorVariant === 'h2';
	      const profile = options.profile?.enabled ? createHotspotProfile(options.profile.sampleRate) : null;

	      const board = useIntPath ? new Uint8Array(5) : new Array(5);
	      const swapIndices = new Int32Array(5);
	      const heroSeven = useIntPath ? new Int16Array(7) : new Array(7);
	      const villainSeven = useIntPath ? new Int16Array(7) : new Array(7);

	      let remainingDeckByVillain = null;
	      if (useIntPath) {
	        const heroCardIds = toCardIds(heroCards, new Int16Array(2));
	        if (!heroCardIds) return null;
	        heroSeven[0] = heroCardIds[0];
	        heroSeven[1] = heroCardIds[1];
	        const villainComboIds = allVillainCombos.map((combo) => {
	          const c0 = cardTextToId(combo?.[0]);
	          const c1 = cardTextToId(combo?.[1]);
	          return [c0, c1];
	        }).filter((pair) => pair[0] >= 0 && pair[1] >= 0);
	        if (villainComboIds.length === 0) return null;
	        remainingDeckByVillain = buildRemainingDeckByVillainIds(heroCardIds, villainComboIds);
	        allVillainCombos = villainComboIds;
	      } else {
	        const [h0, h1] = heroCards;
	        heroSeven[0] = h0;
	        heroSeven[1] = h1;
	        remainingDeckByVillain = buildRemainingDeckByVillain(heroCards, allVillainCombos);
	      }

	      const heroScratch = useIntPath ? createEvaluatorScratch() : null;
	      const villainScratch = useIntPath ? createEvaluatorScratch() : null;
      let totalWins = 0;
      let totalTies = 0;
      let totalTrials = 0;
      const progressTotal = samplePlan.kind === 'adaptive' ? samplePlan.maxSamples : samplePlan.maxSamples;
      const loopLimit = samplePlan.maxSamples;
      const minSamples = samplePlan.kind === 'adaptive' ? samplePlan.minSamples : samplePlan.maxSamples;
      const startedAt = performance.now();
      let stopReason = samplePlan.kind === 'adaptive' ? 'max_samples' : 'fixed_samples';

	      for (let i = 0; i < loopLimit; i++) {
	        if ((i & 255) === 0) {
	          if (typeof shouldCancel === 'function' && shouldCancel()) {
	            return {
              canceled: true,
              totalWins,
              totalTies,
              totalTrials,
              progressTotal,
              stopReason: 'canceled',
              elapsedMs: performance.now() - startedAt,
              evaluatorVariant,
              hotspot: toHotspotBreakdown(profile, totalTrials),
            };
          }
	          if (onProgress) onProgress(i, progressTotal);
	          await nextFrame();
	          if (samplePlan.kind === 'adaptive' && i >= minSamples) {
	            if (Number.isFinite(samplePlan.targetErrorPct) && samplePlan.targetErrorPct > 0 && totalTrials > 0) {
	              const stats = calculateMonteCarloStats(totalWins, totalTies, totalTrials);
	              if (stats.errorPct <= samplePlan.targetErrorPct) {
	                stopReason = 'error_budget';
	                break;
	              }
	            }
	            const elapsed = performance.now() - startedAt;
	            if (elapsed >= samplePlan.targetMs) {
	              stopReason = 'time_budget';
	              break;
	            }
          }
        }

        const villainIndex = randomInt(allVillainCombos.length);
	        const villainCards = allVillainCombos[villainIndex];
	        const remainingDeck = remainingDeckByVillain[villainIndex];
	        if (!remainingDeck || remainingDeck.length < 5) continue;

	        const shouldSample = !!profile && (totalTrials % profile.sampleRate === 0);
	        let loopStart = 0;
	        let drawStart = 0;
	        let evalStart = 0;
	        if (shouldSample) loopStart = performance.now();
	        if (shouldSample) drawStart = performance.now();
	        drawBoardFromDeck(remainingDeck, board, swapIndices);
	        if (shouldSample) profile.drawMs += performance.now() - drawStart;

	        heroSeven[2] = board[0];
	        heroSeven[3] = board[1];
        heroSeven[4] = board[2];
        heroSeven[5] = board[3];
        heroSeven[6] = board[4];
        villainSeven[0] = villainCards[0];
        villainSeven[1] = villainCards[1];
        villainSeven[2] = board[0];
        villainSeven[3] = board[1];
        villainSeven[4] = board[2];
        villainSeven[5] = board[3];
        villainSeven[6] = board[4];

	        if (shouldSample) evalStart = performance.now();
	        let heroScore = 0;
	        let villainScore = 0;
	        if (useIntPath) {
	          heroScore = evaluate7FastFromIds(heroSeven, heroScratch);
	          villainScore = evaluate7FastFromIds(villainSeven, villainScratch);
	        } else if (evaluatorVariant === 'h1') {
	          heroScore = evaluate7Fast(heroSeven);
	          villainScore = evaluate7Fast(villainSeven);
	        } else {
	          heroScore = evaluateLegacy(heroSeven);
	          villainScore = evaluateLegacy(villainSeven);
	        }
	        if (shouldSample) {
	          profile.evalMs += performance.now() - evalStart;
	          profile.loopMs += performance.now() - loopStart;
	          profile.sampled++;
	        }
	        if (heroScore > villainScore) totalWins++;
	        else if (heroScore === villainScore) totalTies++;
	        totalTrials++;
      }

      if (onProgress) onProgress(totalTrials, progressTotal);
      return {
        canceled: false,
        totalWins,
        totalTies,
        totalTrials,
        progressTotal,
        stopReason,
        elapsedMs: performance.now() - startedAt,
        evaluatorVariant,
        intPath: useIntPath,
        hotspot: toHotspotBreakdown(profile, totalTrials),
      };
    }
	    
		    // エクイティ計算（モンテカルロ法）
			    async function calculateWinRate() {
	      const winrateResultDiv = document.getElementById('winrate-result');
	      const calcButton = document.getElementById('calc-winrate-btn');
	      const cancelButton = document.getElementById('cancel-winrate-btn');
	      const modeSelect = document.getElementById('calc-mode');
	      const sampleSelect = document.getElementById('sample-count');

		      const setUiBusy = (busy) => {
		        if (calcButton) {
		          calcButton.disabled = busy;
		          calcButton.textContent = busy ? '計算中...' : 'エクイティ計算';
		        }
	        if (cancelButton) {
	          cancelButton.style.display = busy ? '' : 'none';
	          cancelButton.disabled = !busy;
	          cancelButton.textContent = 'キャンセル';
	        }
	        if (modeSelect) modeSelect.disabled = busy;
	        if (sampleSelect) sampleSelect.disabled = busy;
	      };

	      const setProgressText = (done, total) => {
	        const pct = total > 0 ? (done / total) * 100 : 0;
	        setHudProgress(pct);
	        const progressText = document.getElementById('calc-progress-text');
	        if (progressText) {
	          progressText.textContent = `進捗: ${done.toLocaleString()} / ${total.toLocaleString()} (${pct.toFixed(1)}%)`;
	        }
	      };
	      
	      if (selectedCards.length !== 2) {
	        setHudStatus('手札を2枚選択してください', 'status-negative');
	        winrateResultDiv.innerHTML = '<p class="status-negative">手札を2枚選択してください</p>';
	        return;
	      }

	      const villainCells = getSelectedRangeCells();
	      if (villainCells.length === 0) {
	        setHudStatus('相手レンジを選択してください', 'status-negative');
	        winrateResultDiv.innerHTML = '<p class="status-negative">相手のレンジを選択してください</p>';
	        return;
	      }

		      setUiBusy(true);
		      winrateCancelRequested = false;
		      let canceled = false;
		      try {
		        const sampleCount = parseInt(document.getElementById('sample-count').value, 10);
		        const mode = document.getElementById('calc-mode')?.value === 'fast' ? 'fast' : 'precise';
		        if (!Number.isFinite(sampleCount) || sampleCount < 0 || (mode !== 'fast' && sampleCount <= 0)) {
		          winrateResultDiv.innerHTML = '<p class="status-negative">サンプル数が不正です</p>';
		          return;
		        }
		        const fastSamplePlan = mode === 'fast' ? resolveFastSamplePlan(sampleCount) : null;
		        if (mode === 'fast' && !fastSamplePlan) {
		          winrateResultDiv.innerHTML = '<p class="status-negative">高速モードのサンプル計画が不正です</p>';
		          return;
		        }
		        const startTime = performance.now();
		        const heroCards = selectedCards.slice();
		        const heroCategory = getHandCategory(heroCards[0], heroCards[1]);

		        const allVillainCombos = [];
		        const rangeCategories = [];
		        for (const cell of villainCells) {
		          const handCategory = cell.dataset.hand;
		          if (!handCategory) continue;
		          rangeCategories.push(handCategory);
		          const combos = getCombosForHand(handCategory, heroCards);
		          allVillainCombos.push(...combos);
		        }
	        if (allVillainCombos.length === 0) {
	          setHudStatus('有効コンボがありません', 'status-negative');
	          winrateResultDiv.innerHTML = '<p class="status-negative">ブロッカー効果で相手の有効コンボが0です</p>';
	          return;
	        }

	        winrateResultDiv.innerHTML = `
	          <h3>計算中...</h3>
	          <p>モード: ${mode === 'fast' ? '高速' : '精密'}</p>
	          <p>相手有効コンボ: ${allVillainCombos.length.toLocaleString()}</p>
	          <p id="calc-progress-text">進捗: 0 / 0 (0.0%)</p>
	        `;
	        setHudStatus('計算中', 'status-neutral');
	        setHudProgress(0);
	        setHudEquityValue(null, null);

		        let totalWins = 0;
		        let totalTies = 0;
		        let totalTrials = 0;
		        let fastRunMeta = null;

		        if (mode === 'fast') {
		          const totalSteps = fastSamplePlan.maxSamples;
		          setProgressText(0, totalSteps);
		          const fastResult = await simulateFastEquity(
		            heroCards,
		            rangeCategories,
		            sampleCount,
		            (done, totalHint) => {
		              const totalForDisplay = Number.isFinite(totalHint) && totalHint > 0 ? totalHint : totalSteps;
		              setProgressText(done, totalForDisplay);
		            },
		            {
		              samplePlan: fastSamplePlan,
		              shouldCancel: () => winrateCancelRequested,
		              precomputedCombos: allVillainCombos,
		              useCache: true,
		            },
		          );
		          if (!fastResult || fastResult.canceled) {
		            canceled = true;
		          } else {
		            totalWins = fastResult.totalWins;
		            totalTies = fastResult.totalTies;
		            totalTrials = fastResult.totalTrials;
		            fastRunMeta = fastResult;
		            setProgressText(fastResult.totalTrials, fastResult.progressTotal || totalSteps);
		          }
		        } else {
		          const h0 = heroCards[0];
		          const h1 = heroCards[1];
		          const remainingDeck = new Array(FULL_DECK.length - 4);
		          const board = new Array(5);
		          const swapIndices = new Int32Array(5);
		          const heroSeven = new Array(7);
		          heroSeven[0] = h0;
		          heroSeven[1] = h1;
		          const villainSeven = new Array(7);
		          let processedCombos = 0;
		          const totalSteps = allVillainCombos.length;
		          const batchSize = 4;
	          setProgressText(0, totalSteps);

	          for (let batchStart = 0; batchStart < allVillainCombos.length; batchStart += batchSize) {
	            if (winrateCancelRequested) {
	              canceled = true;
	              break;
	            }
	            const batchEnd = Math.min(batchStart + batchSize, allVillainCombos.length);

	            for (let idx = batchStart; idx < batchEnd; idx++) {
	              const villainCards = allVillainCombos[idx];
	              const v0 = villainCards[0];
	              const v1 = villainCards[1];
	              villainSeven[0] = v0;
	              villainSeven[1] = v1;

	              let remainingLen = 0;
	              for (const c of FULL_DECK) {
	                if (c === h0 || c === h1 || c === v0 || c === v1) continue;
	                remainingDeck[remainingLen++] = c;
	              }
	              remainingDeck.length = remainingLen;

	              for (let i = 0; i < sampleCount; i++) {
	                if ((i & 255) === 0 && winrateCancelRequested) {
	                  canceled = true;
	                  break;
	                }
	                drawBoardFromDeck(remainingDeck, board, swapIndices);
	                heroSeven[2] = board[0];
	                heroSeven[3] = board[1];
	                heroSeven[4] = board[2];
	                heroSeven[5] = board[3];
	                heroSeven[6] = board[4];
	                villainSeven[2] = board[0];
	                villainSeven[3] = board[1];
	                villainSeven[4] = board[2];
	                villainSeven[5] = board[3];
	                villainSeven[6] = board[4];

	                const heroScore = evaluateLegacy(heroSeven);
	                const villainScore = evaluateLegacy(villainSeven);
	                if (heroScore > villainScore) totalWins++;
	                else if (heroScore === villainScore) totalTies++;
	                totalTrials++;

	                if ((i & 1023) === 0) {
	                  await nextFrame();
	                }
	              }
	              if (canceled) break;
	              processedCombos++;
	              setProgressText(processedCombos, totalSteps);
	            }
	            if (canceled) break;
	            await nextFrame();
	          }
	        }

	        if (canceled) {
	          setHudStatus('計算をキャンセルしました', 'status-neutral');
	          setHudProgress(0);
	          winrateResultDiv.innerHTML = '<p class="status-neutral">計算をキャンセルしました</p>';
	          return;
	        }

	        const totalOutcome = totalWins + totalTies * 0.5;
	        const heroEquity = totalTrials > 0 ? (totalOutcome / totalTrials) * 100 : 0;
	        const winPct = totalTrials > 0 ? (totalWins / totalTrials) * 100 : 0;
	        const tiePct = totalTrials > 0 ? (totalTies / totalTrials) * 100 : 0;
	        const losePct = Math.max(0, 100 - winPct - tiePct);
	        const meanOutcome = totalTrials > 0 ? (totalOutcome / totalTrials) : 0;
	        const secondMoment = totalTrials > 0 ? ((totalWins + totalTies * 0.25) / totalTrials) : 0;
	        const variance = Math.max(0, secondMoment - meanOutcome * meanOutcome);
	        const stderr = totalTrials > 0 ? Math.sqrt(variance / totalTrials) : 0;
	        const errorMargin = stderr * 1.96 * 100;
	        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);

	        setCalculatedEquity(heroEquity, errorMargin);
	        setHudProgress(100);

			        const fastCacheLabel = fastRunMeta?.cache?.state === 'hit'
			          ? ' / cache hit'
			          : (fastRunMeta?.cache?.state === 'miss' ? ' / cache miss' : '');
				        const evaluatorLabel = fastRunMeta?.evaluatorVariant ? ` / 評価器:${fastRunMeta.evaluatorVariant}` : '';
				        const sampleDesc = mode === 'fast'
				          ? (fastRunMeta?.samplePlanKind === 'adaptive'
				            ? `AUTO ${totalTrials.toLocaleString()}試行 (目標${FAST_ADAPTIVE_TARGET_MS}ms / 誤差±${(Number.isFinite(fastRunMeta?.targetErrorPct) ? fastRunMeta.targetErrorPct : FAST_ADAPTIVE_TARGET_ERROR_PCT).toFixed(1)}% / 上限${(fastRunMeta.progressTotal || FAST_ADAPTIVE_MAX_SAMPLES).toLocaleString()}試行 / 停止:${getAdaptiveStopReasonLabel(fastRunMeta?.stopReason)}${fastCacheLabel}${evaluatorLabel})`
				            : `${totalTrials.toLocaleString()} 試行${fastCacheLabel}${evaluatorLabel}`)
				          : `${sampleCount.toLocaleString()} 回/コンボ × ${allVillainCombos.length.toLocaleString()} コンボ`;
	        winrateResultDiv.innerHTML = `
	          <h3>計算結果</h3>
	          <p>ヒーロー: <strong>${heroCards[0]} ${heroCards[1]} (${heroCategory})</strong></p>
	          <p>相手レンジ: ${villainCells.length}カテゴリ / 169 (${(villainCells.length / 169 * 100).toFixed(1)}%)</p>
	          <p>有効コンボ: ${allVillainCombos.length.toLocaleString()} / 1326 (${((allVillainCombos.length / 1326) * 100).toFixed(1)}%)</p>
	          <p>モード: <strong>${mode === 'fast' ? '高速' : '精密'}</strong> / 試行: ${sampleDesc}</p>
	          <p>計算時間: ${elapsed}秒</p>
	          <hr>
	          <p>エクイティ: <strong style="font-size:1.6em; color:${heroEquity >= 50 ? '#7de4a0' : '#ff8b8b'}">${heroEquity.toFixed(2)}%</strong> <span style="color:#bcd6c3">(±${errorMargin.toFixed(2)}%)</span></p>
	          <p>内訳: 勝ち ${winPct.toFixed(2)}% / 引分 ${tiePct.toFixed(2)}% / 負け ${losePct.toFixed(2)}%</p>
	        `;
	      } finally {
	        setUiBusy(false);
	      }
	    }

	    async function simulateFastEquity(heroCards, rangeCategories, sampleCount, onProgress = null, opts = {}) {
	      const options = opts || {};
	      const samplePlan = options.samplePlan || resolveFastSamplePlan(sampleCount);
	      if (!samplePlan) return null;
	      const evaluatorVariant = normalizeEvaluatorVariant(options.evaluatorVariant || activeEvaluatorVariant);

	      let allVillainCombos = Array.isArray(options.precomputedCombos) ? options.precomputedCombos.slice() : null;
	      if (!allVillainCombos) {
	        allVillainCombos = [];
	        for (const cat of rangeCategories || []) {
	          allVillainCombos.push(...getCombosForHand(cat, heroCards));
	        }
	      }
	      if (allVillainCombos.length === 0) return null;

	      const useCache = options.useCache !== false;
	      const cacheKey = useCache ? buildFastEquityCacheKey(heroCards, rangeCategories || [], samplePlan, evaluatorVariant) : null;
	      if (cacheKey) {
	        const cached = readFastEquityCache(cacheKey);
	        if (cached) {
	          if (onProgress) onProgress(cached.totalTrials, cached.progressTotal || cached.totalTrials);
	          return {
	            ...cached,
	            cache: { state: 'hit', key: cacheKey },
	          };
	        }
	      }

	      const runResult = await runFastEquityMonteCarlo(
	        heroCards,
	        allVillainCombos,
	        samplePlan,
	        onProgress,
	        options.shouldCancel || null,
	        {
	          evaluatorVariant,
	          profile: options.profile || null,
	        },
	      );
	      if (!runResult) return null;
		      if (runResult.canceled) {
		        return {
		          canceled: true,
		          ...runResult,
		          samplePlanKind: samplePlan.kind,
		          targetMs: samplePlan.targetMs || null,
		          targetErrorPct: samplePlan.targetErrorPct || null,
		          evaluatorVariant,
		          cache: cacheKey ? { state: 'miss', key: cacheKey } : null,
		        };
		      }

		      const totalTrials = runResult.totalTrials;
		      const stats = calculateMonteCarloStats(runResult.totalWins, runResult.totalTies, totalTrials);
		      const result = {
		        equity: stats.equity,
		        errorPct: stats.errorPct,
		        combos: allVillainCombos.length,
		        totalTrials,
		        trials: totalTrials,
		        totalWins: runResult.totalWins,
		        totalTies: runResult.totalTies,
	        progressTotal: runResult.progressTotal,
		        stopReason: runResult.stopReason,
		        elapsedMs: runResult.elapsedMs,
		        samplePlanKind: samplePlan.kind,
		        targetMs: samplePlan.targetMs || null,
		        targetErrorPct: samplePlan.targetErrorPct || null,
		        evaluatorVariant,
		        intPath: !!runResult.intPath,
		        hotspot: runResult.hotspot || null,
		        cache: cacheKey ? { state: 'miss', key: cacheKey } : null,
		      };
	      if (cacheKey) {
	        writeFastEquityCache(cacheKey, result);
	      }
	      return result;
	    }

	    function loadTrainerHistory() {
	      const raw = readJsonFromStorage(TRAINER_HISTORY_KEY, []);
	      if (!Array.isArray(raw)) return [];
	      return raw
	        .map(item => {
	          const hero = String(item?.hero || '');
	          const modeFromHero = hero.startsWith('MDF /') ? 'MDF' : '';
	          const modeRaw = String(item?.mode || '').trim().toLowerCase();
	          const mode = modeRaw === 'mdf' ? 'MDF' : modeFromHero;
	          const guessRaw = item?.guess;
	          const guess = guessRaw === null || guessRaw === '' ? null : Number(guessRaw);
	          const actual = Number(item?.actual);
	          const errorRaw = item?.error;
	          const error = errorRaw === null || errorRaw === '' ? null : Number(errorRaw);
	          const elapsedRaw = Number(item?.elapsedSec);
	          const elapsedSec = Number.isFinite(elapsedRaw) && elapsedRaw >= 0 ? elapsedRaw : 0;
	          const outcome = item?.outcome === 'timeout' ? 'timeout' : 'ok';
	          const savedScore = Number(item?.score);
	          const fallbackScore = Number.isFinite(error) ? Math.max(0, Math.min(100, 100 - error)) : (outcome === 'timeout' ? 0 : 0);
	          const score = Number.isFinite(savedScore) ? Math.max(0, Math.min(100, savedScore)) : fallbackScore;
	          return { hero, mode, guess, actual, error, elapsedSec, score, outcome };
	        })
	        .filter(item => {
	          const supportedMode = item.mode === 'MDF';
	          const baseOk = supportedMode
	            && item.hero
	            && Number.isFinite(item.actual)
	            && Number.isFinite(item.score)
	            && Number.isFinite(item.elapsedSec)
	            && (item.outcome === 'ok' || item.outcome === 'timeout');
	          if (!baseOk) return false;
	          if (item.outcome === 'timeout') return true;
	          return Number.isFinite(item.guess) && Number.isFinite(item.error);
	        })
	        .slice(0, 20);
	    }

	    function saveTrainerHistory() {
	      writeJsonToStorage(TRAINER_HISTORY_KEY, trainerHistory.slice(0, 20));
	    }

	    function renderTrainerHistory() {
	      const list = document.getElementById('trainer-history');
	      if (!list) return;
	      list.innerHTML = '';
	      trainerHistory.slice(0, 20).forEach((row) => {
	        const li = document.createElement('li');
	        const elapsedText = Number.isFinite(row.elapsedSec) ? `${row.elapsedSec.toFixed(2)}秒` : '--';
	        const scoreText = Number.isFinite(row.score) ? `${row.score.toFixed(1)}点` : '--';
	        if (row.outcome === 'timeout') {
	          li.textContent = `${row.hero} TIMEOUT / 得点${scoreText} / 回答時間${elapsedText}`;
	        } else {
	          const guessText = Number.isFinite(row.guess) ? `${row.guess.toFixed(1)}%` : '--';
	          const errorText = Number.isFinite(row.error) ? `${row.error.toFixed(1)}%` : '--';
	          li.textContent = `${row.hero} 回答${guessText} / 正答${row.actual.toFixed(1)}% / 誤差${errorText} / 得点${scoreText} / 回答時間${elapsedText}`;
	        }
	        list.appendChild(li);
	      });
	    }

	    function renderTrainerStats() {
	      const stats = document.getElementById('trainer-stats');
	      if (!stats) return;
	      const rows = trainerHistory.filter((row) => row.mode === 'MDF').slice(0, 20);
	      if (rows.length === 0) {
	        stats.innerHTML = 'MDF平均得点: -- (0問)<br><span class="icm-hint">MDF平均誤差: -- (0問)</span>';
	        return;
	      }
	      const scoreAvg = rows.reduce((sum, row) => sum + row.score, 0) / rows.length;
	      const errorRows = rows.filter((row) => Number.isFinite(row.error));
	      const errorText = errorRows.length
	        ? `${(errorRows.reduce((sum, row) => sum + row.error, 0) / errorRows.length).toFixed(2)}% (${errorRows.length}問)`
	        : '-- (0問)';
	      stats.innerHTML = `MDF平均得点: ${scoreAvg.toFixed(2)}点 (${rows.length}問)<br><span class="icm-hint">MDF平均誤差: ${errorText}</span>`;
	    }

	    function readTrainerSessionMode() {
	      const mode = document.getElementById('trainer-session-mode')?.value || 'practice';
	      return mode === 'drill' ? 'drill' : 'practice';
	    }

	    function readTrainerTimeLimitSec() {
	      const input = document.getElementById('trainer-time-limit-sec');
	      const value = parseFloat(input?.value || '');
	      return Number.isFinite(value) && value > 0 ? value : null;
	    }

	    function stopTrainerTimer() {
	      if (trainerTimerIntervalId !== null) {
	        clearInterval(trainerTimerIntervalId);
	        trainerTimerIntervalId = null;
	      }
	      trainerQuestionTimeoutAtMs = null;
	    }

	    function updateTrainerTimerDisplay(overrideText = null) {
	      const timerEl = document.getElementById('trainer-timer');
	      if (!timerEl) return;
	      if (typeof overrideText === 'string') {
	        timerEl.textContent = overrideText;
	        return;
	      }
	      if (!currentTrainerQuestion) {
	        timerEl.textContent = '残り時間: --';
	        return;
	      }
	      if (currentTrainerQuestion.sessionMode !== 'drill') {
	        timerEl.textContent = '残り時間: 無制限';
	        return;
	      }
	      if (!Number.isFinite(trainerQuestionTimeoutAtMs)) {
	        const fallback = Number.isFinite(currentTrainerQuestion.timeLimitSec) ? currentTrainerQuestion.timeLimitSec : 0;
	        timerEl.textContent = `残り時間: ${fallback.toFixed(1)}秒`;
	        return;
	      }
	      const remainingMs = Math.max(0, trainerQuestionTimeoutAtMs - performance.now());
	      timerEl.textContent = `残り時間: ${(remainingMs / 1000).toFixed(1)}秒`;
	    }

	    function resetTrainerSessionState() {
	      stopTrainerTimer();
	      currentTrainerQuestion = null;
	      trainerQuestionStartedAtMs = null;
	      trainerQuestionTimeoutAtMs = null;
	      const prompt = document.getElementById('trainer-prompt');
	      const feedback = document.getElementById('trainer-feedback');
	      const guessInput = document.getElementById('trainer-guess-input');
	      if (prompt) prompt.textContent = '「出題」を押して開始してください。';
	      if (feedback) feedback.textContent = '';
	      if (guessInput) guessInput.value = '';
	      updateTrainerTimerDisplay('残り時間: --');
	    }

	    function computeTrainerScore(error, sessionMode, elapsedSec, timeLimitSec) {
	      const accuracyScore = Math.max(0, Math.min(100, 100 - error));
	      if (sessionMode !== 'drill') return accuracyScore;
	      const safeLimit = Number.isFinite(timeLimitSec) && timeLimitSec > 0 ? timeLimitSec : 8;
	      const speedScore = Math.max(0, Math.min(100, ((safeLimit - elapsedSec) / safeLimit) * 100));
	      return Math.max(0, Math.min(100, accuracyScore * 0.7 + speedScore * 0.3));
	    }

	    function computeTrainerScoreDetail(error, sessionMode, elapsedSec, timeLimitSec) {
	      const accuracyScore = Math.max(0, Math.min(100, 100 - error));
	      if (sessionMode !== 'drill') {
	        return {
	          accuracyScore,
	          speedScore: null,
	          score: accuracyScore,
	          safeLimit: null,
	        };
	      }
	      const safeLimit = Number.isFinite(timeLimitSec) && timeLimitSec > 0 ? timeLimitSec : 8;
	      const speedScore = Math.max(0, Math.min(100, ((safeLimit - elapsedSec) / safeLimit) * 100));
	      const score = computeTrainerScore(error, sessionMode, elapsedSec, safeLimit);
	      return {
	        accuracyScore,
	        speedScore,
	        score,
	        safeLimit,
	      };
	    }

	    function buildTrainerSolutionHtml(question) {
	      if (!question) return '解法: 問題情報がありません。';
	      const prePot = Number(question.prePot);
	      const ratioLabel = String(question.ratioLabel || '');
	      const bet = Number(question.bet);
	      const pAfter = Number(question.pAfter);
	      return `解法: MDF = ポット / 合計ポット<br>途中値: ポット=${prePot}, ベット額(比率 ${ratioLabel})=${bet}, 合計ポット=${prePot}+${bet}=${pAfter}<br>計算: MDF=${prePot}/${pAfter}=${question.answerPct.toFixed(2)}%`;
	    }

	    function pushTrainerResult(row) {
	      trainerHistory.unshift(row);
	      trainerHistory = trainerHistory.slice(0, 20);
	      saveTrainerHistory();
	      renderTrainerHistory();
	      renderTrainerStats();
	    }

	    function handleTrainerTimeout() {
	      if (!currentTrainerQuestion) return;
	      const feedback = document.getElementById('trainer-feedback');
	      const prompt = document.getElementById('trainer-prompt');
	      const modeLabel = 'MDF';
	      const limitSec = Number.isFinite(currentTrainerQuestion.timeLimitSec) ? currentTrainerQuestion.timeLimitSec : 0;
	      const solutionHtml = buildTrainerSolutionHtml(currentTrainerQuestion);
	      if (feedback) {
	        feedback.innerHTML = `TIMEOUT: <strong>${limitSec.toFixed(1)}秒</strong> 以内に回答できなかったため得点 <strong>0.0点</strong><br>正答: <strong>${currentTrainerQuestion.answerPct.toFixed(2)}%</strong><br><span class="icm-hint">${solutionHtml}</span><br><span class="icm-hint">得点内訳: accuracy=0.0 / speed=0.0 / 合成=0.0 (TIMEOUT)</span>`;
	      }
	      if (prompt) {
	        prompt.textContent = '時間切れです。もう一度「出題」を押してください。';
	      }
	      pushTrainerResult({
	        hero: currentTrainerQuestion.label,
	        mode: modeLabel,
	        guess: null,
	        actual: currentTrainerQuestion.answerPct,
	        error: null,
	        elapsedSec: limitSec,
	        score: 0,
	        outcome: 'timeout',
	      });
	      currentTrainerQuestion = null;
	      trainerQuestionStartedAtMs = null;
	      trainerQuestionTimeoutAtMs = null;
	      stopTrainerTimer();
	      updateTrainerTimerDisplay('残り時間: 0.0秒');
	    }

	    function buildTrainerQuestion(sessionMode) {
	      const normalizedSessionMode = sessionMode === 'drill' ? 'drill' : 'practice';
	      const showRatioLabelInPrompt = normalizedSessionMode !== 'drill';
	      const ratioOptions = [
	        { label: '1/3P', num: 1, den: 3 },
	        { label: '1/2P', num: 1, den: 2 },
	        { label: '2/3P', num: 2, den: 3 },
	        { label: '1.0P', num: 1, den: 1 },
	      ];
	      const ratio = ratioOptions[randomInt(ratioOptions.length)];
	      const prePot = (randomInt(10) + 2) * 6;
	      const bet = (prePot * ratio.num) / ratio.den;
	      const pAfter = prePot + bet;
	      const mdfCalc = calcBetEv(prePot, bet, 0);
	      const mdfPct = (mdfCalc.mdf ?? NaN) * 100;
	      return {
	        mode: 'mdf',
	        answerPct: mdfPct,
	        label: `MDF / ポット=${prePot}, 比率=${ratio.label}, ベット=${bet}`,
	        promptHtml: showRatioLabelInPrompt
	          ? `MDFドリル（標準比率）: ポットは <strong>${prePot}</strong>、相手ベットは <strong>${ratio.label}</strong>（ベット額 <strong>${bet}</strong>）です。合計ポットは <strong>${pAfter}</strong>。<br>あなたが最低限守るべき頻度 MDF(%) は?`
	          : `MDFドリル: ポットは <strong>${prePot}</strong>、相手ベット額は <strong>${bet}</strong> です。合計ポットは <strong>${pAfter}</strong>。<br>あなたが最低限守るべき頻度 MDF(%) は?`,
	        prePot,
	        ratioLabel: ratio.label,
	        bet,
	        pAfter,
	      };
	    }

	    function drawTrainerQuestion() {
	      stopTrainerTimer();
	      const prompt = document.getElementById('trainer-prompt');
	      const feedback = document.getElementById('trainer-feedback');
	      const guessInput = document.getElementById('trainer-guess-input');
	      const sessionMode = readTrainerSessionMode();
	      const timeLimitSec = sessionMode === 'drill' ? readTrainerTimeLimitSec() : null;
	      if (sessionMode === 'drill' && timeLimitSec === null) {
	        if (feedback) feedback.textContent = '鍛錬モードでは制限秒数を1以上で入力してください。';
	        const limitInput = document.getElementById('trainer-time-limit-sec');
	        if (limitInput) limitInput.focus();
	        currentTrainerQuestion = null;
	        trainerQuestionStartedAtMs = null;
	        trainerQuestionTimeoutAtMs = null;
	        updateTrainerTimerDisplay('残り時間: --');
	        return;
	      }

	      const question = buildTrainerQuestion(sessionMode);
	      currentTrainerQuestion = { ...question, sessionMode, timeLimitSec };
	      trainerQuestionStartedAtMs = performance.now();
	      trainerQuestionTimeoutAtMs = null;

	      if (guessInput) guessInput.value = '';
	      if (prompt) prompt.innerHTML = currentTrainerQuestion.promptHtml;
	      if (feedback) {
	        feedback.textContent = sessionMode === 'drill'
	          ? `鍛錬モード: ${timeLimitSec.toFixed(1)}秒以内に回答してください。`
	          : '練習モード: 時間制限なし。精度重視で回答してください。';
	      }

	      if (sessionMode === 'drill') {
	        trainerQuestionTimeoutAtMs = trainerQuestionStartedAtMs + timeLimitSec * 1000;
	        updateTrainerTimerDisplay();
	        trainerTimerIntervalId = setInterval(() => {
	          if (!currentTrainerQuestion || currentTrainerQuestion.sessionMode !== 'drill') {
	            stopTrainerTimer();
	            return;
	          }
	          const remainingMs = trainerQuestionTimeoutAtMs - performance.now();
	          if (remainingMs <= 0) {
	            handleTrainerTimeout();
	            return;
	          }
	          updateTrainerTimerDisplay();
	        }, 100);
	      } else {
	        updateTrainerTimerDisplay('残り時間: 無制限');
	      }
	    }

	    function checkTrainerAnswer() {
	      const guessInput = document.getElementById('trainer-guess-input');
	      const feedback = document.getElementById('trainer-feedback');
	      const prompt = document.getElementById('trainer-prompt');
	      if (!guessInput || !feedback) return;

	      if (!currentTrainerQuestion) {
	        feedback.textContent = '先に「出題」を押してください。';
	        return;
	      }
	      if (currentTrainerQuestion.sessionMode === 'drill'
	        && Number.isFinite(trainerQuestionTimeoutAtMs)
	        && performance.now() >= trainerQuestionTimeoutAtMs) {
	        handleTrainerTimeout();
	        return;
	      }

	      const guess = parseFloat(guessInput.value);
	      if (!Number.isFinite(guess) || guess < 0 || guess > 100) {
	        feedback.textContent = '0-100の範囲で予想値を入力してください。';
	        guessInput.focus();
	        return;
	      }

	      const actual = currentTrainerQuestion.answerPct;
	      if (!Number.isFinite(actual)) {
	        feedback.textContent = '入力エラー: 問題生成に失敗';
	        return;
	      }

	      const elapsedSec = trainerQuestionStartedAtMs === null
	        ? 0
	        : Math.max(0, (performance.now() - trainerQuestionStartedAtMs) / 1000);
	      if (currentTrainerQuestion.sessionMode === 'drill'
	        && Number.isFinite(currentTrainerQuestion.timeLimitSec)
	        && elapsedSec > currentTrainerQuestion.timeLimitSec) {
	        handleTrainerTimeout();
	        return;
	      }

	      const error = Math.abs(guess - actual);
	      const scoreDetail = computeTrainerScoreDetail(
	        error,
	        currentTrainerQuestion.sessionMode,
	        elapsedSec,
	        currentTrainerQuestion.timeLimitSec,
	      );
	      const solutionHtml = buildTrainerSolutionHtml(currentTrainerQuestion);
	      const scoreText = `正答: <strong>${actual.toFixed(2)}%</strong> / 誤差: <strong>${error.toFixed(2)}%</strong> / 回答時間: <strong>${elapsedSec.toFixed(2)}秒</strong> / 得点: <strong>${scoreDetail.score.toFixed(1)}点</strong>`;
	      const drillBreakdownText = currentTrainerQuestion.sessionMode === 'drill'
	        ? `<br><span class="icm-hint">得点内訳: accuracy=${scoreDetail.accuracyScore.toFixed(1)} / speed=${scoreDetail.speedScore.toFixed(1)} / 合成=${scoreDetail.score.toFixed(1)} (0.7*accuracy + 0.3*speed)</span>`
	        : '';
	      feedback.innerHTML = `${scoreText}${drillBreakdownText}<br><span class="icm-hint">${solutionHtml}</span>`;
	      if (prompt) prompt.textContent = '答え合わせ完了。もう一度「出題」を押してください。';

	      pushTrainerResult({
	        hero: currentTrainerQuestion.label,
	        mode: 'MDF',
	        guess,
	        actual,
	        error,
	        elapsedSec,
	        score: scoreDetail.score,
	        outcome: 'ok',
	      });
	      currentTrainerQuestion = null;
	      trainerQuestionStartedAtMs = null;
	      trainerQuestionTimeoutAtMs = null;
	      stopTrainerTimer();
	      updateTrainerTimerDisplay('残り時間: --');
	    }

	    // ICM計算関数
	    let lastIcmResult = null;

	    const ICM_POSITION_OPTIONS = [
	      { value: 'none', label: '-' },
	      { value: 'utg', label: 'UTG' },
	      { value: 'utg1', label: 'UTG+1' },
	      { value: 'utg2', label: 'UTG+2' },
	      { value: 'lj', label: 'LJ' },
	      { value: 'hj', label: 'HJ' },
	      { value: 'co', label: 'CO' },
	      { value: 'btn', label: 'BTN' },
	      { value: 'sb', label: 'SB' },
	      { value: 'bb', label: 'BB' },
	    ];

	    const ICM_PRE_ALLIN_ACTION_ORDER = {
	      utg: 0,
	      utg1: 1,
	      utg2: 2,
	      lj: 3,
	      hj: 4,
	      co: 5,
	      btn: 6,
	      sb: 7,
	      bb: 8,
	    };

	    function getIcmPositionLabel(value) {
	      const found = ICM_POSITION_OPTIONS.find(o => o.value === value);
	      return found ? found.label : '';
	    }

	    function getIcmPlayerPositionValue(playerIndex) {
	      const el = document.getElementById(`pos${playerIndex}`);
	      return el ? el.value : 'none';
	    }

	    function formatPlayerSeatLabel(playerIndex) {
	      return `P${playerIndex + 1}`;
	    }

	    function formatPlayerLabel(playerIndex) {
	      const seat = formatPlayerSeatLabel(playerIndex);
	      const posValue = getIcmPlayerPositionValue(playerIndex);
	      const posLabel = getIcmPositionLabel(posValue);
	      return posValue !== 'none' && posLabel ? `${seat}(${posLabel})` : seat;
	    }

	    function getIcmPreAllInActionRank(playerIndex) {
	      const posValue = getIcmPlayerPositionValue(playerIndex);
	      return Object.prototype.hasOwnProperty.call(ICM_PRE_ALLIN_ACTION_ORDER, posValue)
	        ? ICM_PRE_ALLIN_ACTION_ORDER[posValue]
	        : null;
	    }

	    function canIcmPlayerActBeforeAllIn(playerIndex, allinIndex) {
	      if (!Number.isFinite(allinIndex) || allinIndex < 0) return true;
	      if (playerIndex === allinIndex) return false;
	      const playerRank = getIcmPreAllInActionRank(playerIndex);
	      const allinRank = getIcmPreAllInActionRank(allinIndex);
	      if (!Number.isFinite(playerRank) || !Number.isFinite(allinRank)) return true;
	      return playerRank < allinRank;
	    }

	    function escapeHtml(value) {
	      return String(value ?? '')
	        .replace(/&/g, '&amp;')
	        .replace(/</g, '&lt;')
	        .replace(/>/g, '&gt;')
	        .replace(/"/g, '&quot;')
	        .replace(/'/g, '&#39;');
	    }

	    function renderIcmTableVisual() {
	      const visualEl = document.getElementById('icm-table-visual');
	      if (!visualEl) return;
	      const n = parseInt(document.getElementById('num-players')?.value, 10);
	      if (!Number.isFinite(n) || n <= 0) {
	        visualEl.innerHTML = '';
	        return;
	      }
	      const heroIndex = parseInt(document.getElementById('hero-index')?.value, 10);
	      const allinIndex = parseInt(document.getElementById('allin-index')?.value, 10);
	      const heroHandText = document.getElementById('icm-assumed-hero-hand')?.textContent?.trim() || '--';

	      let html = '';
	      for (let i = 0; i < n; i++) {
	        const angle = (-Math.PI / 2) + (2 * Math.PI * i / n);
	        const left = 50 + 42 * Math.cos(angle);
	        const top = 50 + 34 * Math.sin(angle);
	        const posValue = getIcmPlayerPositionValue(i);
	        const posLabel = getIcmPositionLabel(posValue);
	        const stackRaw = document.getElementById(`stack${i}`)?.value?.trim() ?? '';
	        const stackNum = stackRaw === '' ? NaN : parseFloat(stackRaw);
	        const stackText = Number.isFinite(stackNum) ? `${stackNum.toFixed(1)}BB` : '-- BB';
	        const actionText = document.getElementById(`icm-player-action${i}`)?.textContent?.trim() || '-';
	        const heroClass = i === heroIndex ? ' hero' : '';
	        const villainClass = i === allinIndex ? ' villain' : '';
	        const roleText = i === heroIndex ? 'あなた' : (i === allinIndex ? 'オールイン' : '');
	        const posBadgeClass = posValue === 'btn'
	          ? 'icm-pos-badge icm-pos-btn'
	          : posValue === 'sb'
	            ? 'icm-pos-badge icm-pos-sb'
	            : posValue === 'bb'
	              ? 'icm-pos-badge icm-pos-bb'
	              : 'icm-pos-badge';
	        const handText = i === heroIndex ? heroHandText : '--';

	        html += `
	          <div class="icm-seat${heroClass}${villainClass}" style="left:${left.toFixed(2)}%; top:${top.toFixed(2)}%;">
	            <div class="icm-seat-head">
	              <span>${escapeHtml(formatPlayerSeatLabel(i))}</span>
	              <span class="${posBadgeClass}">${escapeHtml(posLabel || '-')}</span>
	            </div>
	            <div class="icm-seat-role">${escapeHtml(roleText)}</div>
	            <div class="icm-seat-stack">${escapeHtml(stackText)}</div>
	            <div class="icm-seat-hand">手札: ${escapeHtml(handText)}</div>
	            <div class="icm-seat-action">${escapeHtml(actionText)}</div>
	          </div>
	        `;
	      }
	      visualEl.innerHTML = html;
      const seatCount = visualEl.querySelectorAll('.icm-seat').length;
      const rect = visualEl.getBoundingClientRect();
      const display = window.getComputedStyle(visualEl).display;
      visualEl.dataset.seatCount = String(seatCount);
      visualEl.dataset.tableRect = `${Math.round(rect.width)}x${Math.round(rect.height)}`;
      visualEl.dataset.tableDisplay = display;
      console.info(`[ICM_TABLE] seats=${seatCount} players=${n} size=${Math.round(rect.width)}x${Math.round(rect.height)} display=${display}`);
	    }

	    function getIcmPositionSelectHtml(id) {
	      const options = ICM_POSITION_OPTIONS.map(o => `<option value="${o.value}">${o.label}</option>`).join('');
	      return `<select id="${id}">${options}</select>`;
	    }

	    function rebuildIcmPlayerSelectOptions(selectEl, n) {
	      if (!selectEl) return;
	      const prev = selectEl.value;
	      selectEl.innerHTML = '';
	      for (let i = 0; i < n; i++) {
	        const opt = document.createElement('option');
	        opt.value = String(i);
	        opt.text = formatPlayerLabel(i);
	        selectEl.appendChild(opt);
	      }
	      if (prev !== '' && Number.isFinite(parseInt(prev)) && parseInt(prev) >= 0 && parseInt(prev) < n) {
	        selectEl.value = prev;
	      }
	    }

	    function updateIcmPlayerHighlights() {
	      const n = parseInt(document.getElementById('num-players').value);
	      const heroIndex = parseInt(document.getElementById('hero-index').value);
	      const allinIndex = parseInt(document.getElementById('allin-index').value);
	      for (let i = 0; i < n; i++) {
	        const row = document.getElementById(`icm-player-row${i}`);
	        if (!row) continue;
	        row.classList.remove('icm-player-hero', 'icm-player-villain');
	        if (i === heroIndex) row.classList.add('icm-player-hero');
	        if (i === allinIndex) row.classList.add('icm-player-villain');
	      }
	      renderIcmTableVisual();
	    }

	    function clearIcmActionRows() {
	      const tbody = document.getElementById('icm-action-rows');
	      if (!tbody) return;
	      tbody.innerHTML = '';
	      updateIcmActionRowNumbers();
	      renderIcmPlayerActionSummary();
	    }

	    function updateIcmActionRowNumbers() {
	      const tbody = document.getElementById('icm-action-rows');
	      if (!tbody) return;
	      const rows = Array.from(tbody.querySelectorAll('tr'));
	      rows.forEach((row, idx) => {
	        const stepTd = row.querySelector('.icm-action-step');
	        if (stepTd) stepTd.textContent = String(idx + 1);
	      });
	    }

    function appendIcmActionPlayerOptions(selectEl, n) {
      if (!selectEl) return;
      const allinIndex = parseInt(document.getElementById('allin-index')?.value || '', 10);
      const options = [];
      for (let i = 0; i < n; i++) {
        if (Number.isFinite(allinIndex) && i !== allinIndex && !canIcmPlayerActBeforeAllIn(i, allinIndex)) {
          continue;
        }
        const rank = getIcmPreAllInActionRank(i);
        options.push({
          index: i,
          rank: Number.isFinite(rank) ? rank : Number.POSITIVE_INFINITY,
          isAllin: Number.isFinite(allinIndex) && i === allinIndex,
        });
      }
      options.sort((a, b) => a.rank - b.rank);
      let hasEnabledOption = false;
      for (const option of options) {
        const i = option.index;
        const opt = document.createElement('option');
        opt.value = String(i);
        if (option.isAllin) {
          opt.text = `${formatPlayerLabel(i)}（オールイン相手/自動）`;
          opt.disabled = true;
        } else {
          opt.text = formatPlayerLabel(i);
          hasEnabledOption = true;
        }
        selectEl.appendChild(opt);
      }
	      if (!hasEnabledOption) {
	        const opt = document.createElement('option');
	        opt.value = '';
	        opt.text = '（追加可能なプレイヤーなし）';
	        opt.disabled = true;
	        opt.selected = true;
	        selectEl.appendChild(opt);
	      }
	    }

	    function refreshIcmActionPlayerOptionTexts() {
	      const n = parseInt(document.getElementById('num-players').value);
	      const tbody = document.getElementById('icm-action-rows');
	      if (!tbody) return;
	      const allinIndex = parseInt(document.getElementById('allin-index')?.value || '', 10);
	      for (const row of tbody.querySelectorAll('tr')) {
	        const select = row.querySelector('.icm-action-player');
	        if (!select) continue;
	        const prev = select.value;
	        select.innerHTML = '';
	        appendIcmActionPlayerOptions(select, n);
	        const prevIndex = parseInt(prev, 10);
	        if (prev !== ''
	          && Number.isFinite(prevIndex)
	          && prevIndex >= 0
	          && prevIndex < n
	          && (!Number.isFinite(allinIndex) || prevIndex !== allinIndex)) {
	          select.value = prev;
	        } else {
	          const firstEnabled = Array.from(select.options).find(opt => !opt.disabled);
	          if (firstEnabled) select.value = firstEnabled.value;
	        }
	      }
	    }

		    function setIcmActionRowAmountMode(row) {
		      const typeEl = row.querySelector('.icm-action-type');
		      const input = row.querySelector('.icm-action-to');
		      if (!typeEl || !input) return;
		      const type = typeEl.value;

		      if (type === 'fold') {
		        input.disabled = true;
		        input.readOnly = false;
		        input.value = '';
		        return;
		      }

		      input.disabled = false;
		      input.readOnly = (type === 'callTo');
		    }

		    function refreshIcmCallToAutoValues() {
		      const tbody = document.getElementById('icm-action-rows');
		      if (!tbody) return;
		      const rows = Array.from(tbody.querySelectorAll('tr'));
		      let currentBetTo = 1.0; // SB=0.5 / BB=1.0 固定

		      for (const row of rows) {
		        const typeEl = row.querySelector('.icm-action-type');
		        const toEl = row.querySelector('.icm-action-to');
		        if (!typeEl || !toEl) continue;

		        const type = typeEl.value;
		        if (type === 'fold') continue;

		        if (type === 'callTo') {
		          if (toEl.readOnly) toEl.value = currentBetTo.toFixed(2);
		          continue;
		        }

		        if (type === 'raiseTo') {
		          const str = toEl.value.trim();
		          if (str === '') continue;
		          const v = parseFloat(str);
		          if (!Number.isFinite(v)) continue;
		          if (v > currentBetTo) currentBetTo = v;
		        }
		      }
		    }

			    function addIcmActionRow(preset = {}) {
			      const n = parseInt(document.getElementById('num-players').value);
			      const tbody = document.getElementById('icm-action-rows');
			      if (!tbody) return;
		      const allinIndex = parseInt(document.getElementById('allin-index')?.value || '', 10);
		      let hasSelectablePlayer = false;
		      for (let i = 0; i < n; i++) {
		        if (canIcmPlayerActBeforeAllIn(i, allinIndex)) {
		          hasSelectablePlayer = true;
		          break;
		        }
		      }
		      if (!hasSelectablePlayer) {
		        setIcmError('オールイン前に行動できるプレイヤーがいません。アクション追加は不要です');
		        return;
		      }

	      const tr = document.createElement('tr');
	      tr.innerHTML = `
	        <td class="icm-action-step"></td>
	        <td>
	          <select class="icm-action-player"></select>
	        </td>
	        <td>
	          <select class="icm-action-type">
	            <option value="raiseTo">レイズ(to)</option>
	            <option value="callTo">コール(to)</option>
	            <option value="fold">フォールド</option>
	          </select>
	        </td>
	        <td>
	          <input type="number" class="icm-action-to" step="0.1" min="0" placeholder="例: 2.5">
	        </td>
	        <td>
	          <button type="button" class="icm-remove-action-btn">×</button>
	        </td>
	      `;
	      tbody.appendChild(tr);

	      const playerSelect = tr.querySelector('.icm-action-player');
	      appendIcmActionPlayerOptions(playerSelect, n);
	      if (Number.isFinite(preset.playerIndex)
	        && preset.playerIndex >= 0
	        && preset.playerIndex < n
	        && (!Number.isFinite(allinIndex) || preset.playerIndex !== allinIndex)) {
	        playerSelect.value = String(preset.playerIndex);
	      } else {
	        const firstEnabled = Array.from(playerSelect.options).find(opt => !opt.disabled);
	        if (firstEnabled) playerSelect.value = firstEnabled.value;
	      }

	      const typeSelect = tr.querySelector('.icm-action-type');
	      if (preset.type) typeSelect.value = preset.type;

	      const amountInput = tr.querySelector('.icm-action-to');
	      if (preset.toAmount !== undefined && preset.toAmount !== null) amountInput.value = String(preset.toAmount);

			      setIcmActionRowAmountMode(tr);
			      refreshIcmCallToAutoValues();
			      updateIcmActionRowNumbers();
			      renderIcmPlayerActionSummary();
			    }

		    function getIcmFoldedPlayersFromActionRows(n) {
		      const folded = new Array(n).fill(false);
		      const tbody = document.getElementById('icm-action-rows');
		      if (!tbody) return { folded, error: null };
		      const rows = Array.from(tbody.querySelectorAll('tr'));
		      for (let i = 0; i < rows.length; i++) {
		        const step = i + 1;
		        const row = rows[i];
		        const playerEl = row.querySelector('.icm-action-player');
		        const typeEl = row.querySelector('.icm-action-type');
		        if (!playerEl || !typeEl) return { folded, error: `アクション#${step}: 入力行が不正です` };

		        const playerIndexRaw = playerEl.value;
		        const playerIndex = parseInt(playerIndexRaw);
		        if (!Number.isFinite(playerIndex) || playerIndex < 0 || playerIndex >= n) {
		          return { folded, error: `アクション#${step}: プレイヤーが不正です: ${playerIndexRaw}` };
		        }
		        if (typeEl.value === 'fold') folded[playerIndex] = true;
		      }
		      return { folded, error: null };
		    }

	    function addIcmFoldOthers() {
	      clearIcmError();
	      const n = parseInt(document.getElementById('num-players').value);
		      const heroIndex = parseInt(document.getElementById('hero-index').value);
		      const allinIndex = parseInt(document.getElementById('allin-index').value);
		      if (!Number.isFinite(heroIndex) || heroIndex < 0 || heroIndex >= n) {
		        setIcmError('ヒーローが不正です');
		        return;
		      }
		      if (!Number.isFinite(allinIndex) || allinIndex < 0 || allinIndex >= n) {
		        setIcmError('オールイン相手が不正です');
		        return;
		      }

      const foldState = getIcmFoldedPlayersFromActionRows(n);
      if (foldState.error) {
        setIcmError(foldState.error);
        return;
      }

      const foldTargets = [];
      for (let i = 0; i < n; i++) {
        if (i === heroIndex || i === allinIndex) continue;
        if (foldState.folded[i]) continue;
        if (!canIcmPlayerActBeforeAllIn(i, allinIndex)) continue;
        foldTargets.push({
          playerIndex: i,
          rank: getIcmPreAllInActionRank(i),
        });
      }

      foldTargets.sort((a, b) => {
        const rankA = Number.isFinite(a.rank) ? a.rank : Number.POSITIVE_INFINITY;
        const rankB = Number.isFinite(b.rank) ? b.rank : Number.POSITIVE_INFINITY;
        return rankA - rankB;
      });
      if (foldTargets.length === 0) {
        setIcmError('追加するプレイヤーがいません（オールイン前に行動できる席がありません）');
        return;
      }
      for (const target of foldTargets) {
        addIcmActionRow({ playerIndex: target.playerIndex, type: 'fold' });
        foldState.folded[target.playerIndex] = true;
      }
	    }

	    function setIcmDrillFeedback(message, toneClass = 'status-neutral') {
	      const feedbackEl = document.getElementById('icm-drill-feedback');
	      if (!feedbackEl) return;
	      feedbackEl.textContent = message;
	      feedbackEl.classList.remove('status-positive', 'status-negative', 'status-neutral');
	      if (toneClass) feedbackEl.classList.add(toneClass);
	    }

	    function setIcmDrillPrompt(message) {
	      const promptEl = document.getElementById('icm-drill-prompt');
	      if (!promptEl) return;
	      promptEl.textContent = message;
	    }

	    function setIcmDrillResultPanelHidden(hidden) {
	      const resultPanel = document.getElementById('icm-results');
	      if (!resultPanel) return;
	      resultPanel.classList.toggle('icm-drill-hidden', hidden);
	    }

	    function setIcmDrillAnswerButtonsVisible(visible) {
	      const callBtn = document.getElementById('icm-drill-call-btn');
	      const foldBtn = document.getElementById('icm-drill-fold-btn');
	      [callBtn, foldBtn].forEach((btn) => {
	        if (!btn) return;
	        btn.style.display = visible ? '' : 'none';
	        btn.disabled = !visible;
	      });
	    }

	    function resetIcmDrillQuestion(message = '') {
	      currentIcmDrillQuestion = null;
	      const hasAssumedWinrate = Number.isFinite(readAssumedWinratePct());
	      const defaultMessage = hasAssumedWinrate
	        ? '「出題」を押してください。'
	        : '想定勝率が未設定でも「出題」はできます。回答はプリフロップ計算後に表示します。';
	      setIcmDrillPrompt(message || defaultMessage);
	      setIcmDrillFeedback('待機中', 'status-neutral');
	      setIcmDrillAnswerButtonsVisible(hasAssumedWinrate);
	      setIcmDrillResultPanelHidden(false);
	    }

	    function getIcmDrillPositionOrder(n) {
	      const base = ['btn', 'sb', 'bb', 'utg', 'hj', 'co', 'lj', 'utg1', 'utg2'];
	      return base.slice(0, Math.max(0, n));
	    }

	    function getIcmDrillPrizeTemplate(n) {
	      if (n === 3) return [50, 30, 20];
	      if (n === 4) return [45, 30, 15, 10];
	      if (n === 5) return [40, 28, 18, 9, 5];
	      if (n === 6) return [36, 26, 18, 11, 6, 3];
	      const out = [];
	      for (let i = 0; i < n; i++) out.push(Math.max(0, 40 - i * 6));
	      return out;
	    }

    function getIcmDrillSpotCandidatePairs(n, spotType) {
      const pairs = [];
      for (let allin = 0; allin < n; allin++) {
        const allinRank = getIcmPreAllInActionRank(allin);
        if (!Number.isFinite(allinRank)) continue;
        for (let hero = 0; hero < n; hero++) {
          if (hero === allin) continue;
          const heroRank = getIcmPreAllInActionRank(hero);
          if (!Number.isFinite(heroRank)) continue;
          if (spotType === 'raiseShove') {
            if (heroRank < allinRank) pairs.push({ allinIndex: allin, heroIndex: hero });
          } else if (allinRank < heroRank) {
            pairs.push({ allinIndex: allin, heroIndex: hero });
          }
        }
      }
      return pairs;
    }

    function applyIcmDrillPreAllInActions(n, heroIndex, allinIndex, spotType, raiseTo) {
      clearIcmActionRows();
      if (spotType === 'directShove') {
        addIcmFoldOthers();
        clearIcmError();
        return true;
      }
      if (!Number.isFinite(raiseTo) || (raiseTo !== 2.0 && raiseTo !== 2.5)) return false;

      const actionOrder = [];
      for (let i = 0; i < n; i++) {
        if (i === allinIndex) continue;
        if (!canIcmPlayerActBeforeAllIn(i, allinIndex)) continue;
        const rank = getIcmPreAllInActionRank(i);
        actionOrder.push({
          playerIndex: i,
          rank: Number.isFinite(rank) ? rank : Number.POSITIVE_INFINITY,
        });
      }
      actionOrder.sort((a, b) => a.rank - b.rank);
      if (!actionOrder.some(entry => entry.playerIndex === heroIndex)) return false;

      for (const entry of actionOrder) {
        if (entry.playerIndex === heroIndex) {
          addIcmActionRow({ playerIndex: heroIndex, type: 'raiseTo', toAmount: raiseTo.toFixed(2) });
        } else {
          addIcmActionRow({ playerIndex: entry.playerIndex, type: 'fold' });
        }
      }
      clearIcmError();
      return true;
    }

	    function buildIcmDrillQuestion() {
	      const assumedPct = readAssumedWinratePct();
	      const hasAssumedWinrate = Number.isFinite(assumedPct);
	      const numPlayersEl = document.getElementById('num-players');
	      const heroSelect = document.getElementById('hero-index');
	      const allinSelect = document.getElementById('allin-index');
	      if (!numPlayersEl || !heroSelect || !allinSelect) return null;

	      for (let attempt = 0; attempt < 12; attempt++) {
	        const n = 3 + randomInt(4); // 3-6
	        numPlayersEl.value = String(n);
	        generatePlayerInputs();

	        const posOrder = getIcmDrillPositionOrder(n);
	        const rotateBy = randomInt(n);
	        const posValues = [];
	        for (let i = 0; i < n; i++) {
	          const posEl = document.getElementById(`pos${i}`);
	          if (!posEl) continue;
	          const posValue = posOrder[(i + rotateBy) % n] || 'none';
	          posEl.value = posValue;
	          posValues[i] = posValue;
	        }
        const preferredSpot = lastIcmDrillSpotType === 'raiseShove' ? 'directShove' : 'raiseShove';
        const fallbackSpot = preferredSpot === 'raiseShove' ? 'directShove' : 'raiseShove';
        const spotTypes = [preferredSpot, fallbackSpot];
        const prizes = getIcmDrillPrizeTemplate(n);
        for (let i = 0; i < n; i++) {
          const stackEl = document.getElementById(`stack${i}`);
          const prizeEl = document.getElementById(`prize${i}`);
          if (stackEl) stackEl.value = String(10 + randomInt(26)); // 10-35BB
          if (prizeEl) prizeEl.value = Number.isFinite(prizes[i]) ? prizes[i].toFixed(1) : '0.0';
        }

        for (const spotType of spotTypes) {
          const candidatePairs = getIcmDrillSpotCandidatePairs(n, spotType);
          if (candidatePairs.length === 0) continue;

          const pick = candidatePairs[randomInt(candidatePairs.length)];
          const allinIndex = pick.allinIndex;
          const heroIndex = pick.heroIndex;
          heroSelect.value = String(heroIndex);
          allinSelect.value = String(allinIndex);

          refreshIcmActionPlayerOptionTexts();
          updateIcmPlayerHighlights();

          const raiseTo = spotType === 'raiseShove'
            ? [2.0, 2.5][randomInt(2)]
            : null;
          const applied = applyIcmDrillPreAllInActions(n, heroIndex, allinIndex, spotType, raiseTo);
          if (!applied) {
            clearIcmError();
            continue;
          }

          clearIcmError();
          resetIcmOutputs();
          calculateICM();
          if (!lastIcmResult) continue;

          const errEl = document.getElementById('icm-error');
	          if (errEl && errEl.classList.contains('active')) continue;
	          const foldEv = lastIcmResult.foldEV;
	          if (!Number.isFinite(foldEv)) continue;
	          const requiredWinrateText = document.getElementById('required-winrate')?.textContent || '--';
	          const callAmount = parseFloat(document.getElementById('call-amount')?.textContent ?? '');
	          if (!Number.isFinite(callAmount) || callAmount <= 0) continue;
	          let callEv = null;
	          let evDiff = null;
	          let correctCall = null;
	          if (hasAssumedWinrate) {
	            callEv = parseFloat(document.getElementById('assumed-call-ev')?.textContent ?? '');
	            evDiff = parseFloat(document.getElementById('assumed-ev-diff')?.textContent ?? '');
	            if (!Number.isFinite(callEv) || !Number.isFinite(evDiff)) continue;
	            correctCall = evDiff >= 0;
	          }

	          return {
	            heroIndex,
	            allinIndex,
	            assumedPct: hasAssumedWinrate ? assumedPct : null,
	            hasAssumedWinrate,
	            requiredWinrateText,
	            callEv,
	            foldEv,
	            evDiff,
	            correctCall,
	            spotType,
	            raiseTo,
	          };
        }
	      }
	      return null;
	    }

	    function startIcmDrillQuestion() {
	      clearIcmError();
	      const question = buildIcmDrillQuestion();
	      if (!question) {
	        setIcmDrillResultPanelHidden(false);
	        setIcmError('ICMドリルの問題生成に失敗しました。入力状態を見直して再実行してください');
	        setIcmDrillPrompt('問題生成に失敗しました。');
	        setIcmDrillFeedback('出題失敗: ICM計算の成立条件を満たせませんでした。', 'status-negative');
	        currentIcmDrillQuestion = null;
	        return;
	      }

	      currentIcmDrillQuestion = question;
      lastIcmDrillSpotType = question.spotType || null;
	      const heroLabel = formatPlayerLabel(question.heroIndex);
	      const allinLabel = formatPlayerLabel(question.allinIndex);
      const spotText = question.spotType === 'raiseShove' && Number.isFinite(question.raiseTo)
        ? `【レイズto ${question.raiseTo.toFixed(2)}】 ${heroLabel}が${question.raiseTo.toFixed(2)}BBにレイズ後、${allinLabel}がオールイン。`
        : `【直オールイン】 ${allinLabel}がオールイン。`;
	      if (question.hasAssumedWinrate && Number.isFinite(question.assumedPct) && typeof question.correctCall === 'boolean') {
	        setIcmDrillAnswerButtonsVisible(true);
	        setIcmDrillPrompt(`${spotText} あなたはコール/フォールド？ / 想定勝率 ${question.assumedPct.toFixed(2)}%`);
	        setIcmDrillFeedback('回答を選んでください。', 'status-neutral');
	        setIcmDrillResultPanelHidden(true);
	      } else {
	        setIcmDrillAnswerButtonsVisible(false);
	        setIcmDrillPrompt(`${spotText} 想定勝率が未設定のため、この問題は回答判定なしで表示しています。`);
	        setIcmDrillFeedback('想定勝率が未設定のため回答ボタンは非表示です。プリフロップでエクイティ計算後に再出題してください。', 'status-neutral');
	        setIcmDrillResultPanelHidden(false);
	      }
	    }

	    function submitIcmDrillAnswer(selectedCall) {
	      if (!currentIcmDrillQuestion) {
	        setIcmDrillResultPanelHidden(false);
	        setIcmDrillFeedback('先に「出題」を押してください。', 'status-negative');
	        return;
	      }
	      setIcmDrillResultPanelHidden(false);
	      const q = currentIcmDrillQuestion;
	      if (typeof q.correctCall !== 'boolean') {
	        setIcmDrillFeedback('この問題は想定勝率が未設定のため正誤判定できません。プリフロップでエクイティ計算後に再出題してください。', 'status-negative');
	        setIcmDrillPrompt('回答不可の問題です。「出題」で次の問題へ進んでください。');
	        currentIcmDrillQuestion = null;
	        return;
	      }
	      const selectedLabel = selectedCall ? 'コール' : 'フォールド';
	      const correctLabel = q.correctCall ? 'コール' : 'フォールド';
	      const ok = selectedCall === q.correctCall;
	      const diffSign = q.evDiff >= 0 ? '+' : '';
	      setIcmDrillFeedback(
	        `${ok ? '正解' : '不正解'} / あなた: ${selectedLabel} / 正答: ${correctLabel} / 必要勝率=${q.requiredWinrateText} / foldEV=${q.foldEv.toFixed(2)} / callEV=${q.callEv.toFixed(2)} / EV差=${diffSign}${q.evDiff.toFixed(2)}`,
	        ok ? 'status-positive' : 'status-negative',
	      );
	      setIcmDrillPrompt('回答完了。次の問題は「出題」を押してください。');
	      currentIcmDrillQuestion = null;
	    }

	    function generatePlayerInputs() {
	      const n = parseInt(document.getElementById('num-players').value);
		      const playerInputsDiv = document.getElementById('player-inputs');
		      const heroIndexSelect = document.getElementById('hero-index');
	      const allinIndexSelect = document.getElementById('allin-index');

	      playerInputsDiv.innerHTML = `
	        <div class="icm-section-title">プレイヤー</div>
	        <div class="icm-table-container">
	          <table id="icm-player-table">
	            <thead>
	              <tr>
	                <th>席</th>
	                <th>ポジション</th>
	                <th>スタック(BB)</th>
	                <th>プライズ</th>
	                <th>アクション</th>
	              </tr>
	            </thead>
	            <tbody id="icm-player-rows"></tbody>
	          </table>
	        </div>
	      `;

	      heroIndexSelect.innerHTML = '';
	      allinIndexSelect.innerHTML = '';

	      const tbody = document.getElementById('icm-player-rows');
	      for (let i = 0; i < n; i++) {
	        const tr = document.createElement('tr');
	        tr.id = `icm-player-row${i}`;
	        tr.innerHTML = `
	          <td>${formatPlayerSeatLabel(i)}</td>
	          <td>${getIcmPositionSelectHtml(`pos${i}`)}</td>
	          <td><input type="number" id="stack${i}" step="0.1" min="0" placeholder="BB"></td>
	          <td><input type="number" id="prize${i}" step="0.1" min="0" placeholder="0"></td>
	          <td id="icm-player-action${i}">-</td>
	        `;
	        tbody.appendChild(tr);

	        const posSelect = tr.querySelector(`#pos${i}`);
	        if (posSelect) {
	          if (i === 0) posSelect.value = 'sb';
	          else if (i === 1) posSelect.value = 'bb';
	          else posSelect.value = 'none';
	        }
	      }

	      rebuildIcmPlayerSelectOptions(heroIndexSelect, n);
	      rebuildIcmPlayerSelectOptions(allinIndexSelect, n);
	      if (n >= 2) {
	        heroIndexSelect.value = '0';
	        allinIndexSelect.value = '1';
	      }

	      clearIcmActionRows();
	      updateIcmPlayerHighlights();
	      clearIcmError();
	      resetIcmOutputs();
	      refreshIcmActionPlayerOptionTexts();
	      renderIcmPlayerActionSummary();
	      resetIcmDrillQuestion();
	    }
	    
		    function resetIcmOutputs() {
		      lastIcmResult = null;

		      const setText = (id, text) => {
		        const el = document.getElementById(id);
		        if (el) el.textContent = text;
		      };

		      setText('effective-stack', '0.00');
		      setText('villain-allin-to', '0.00');
		      setText('pot-fold', '0.00');
		      setText('fold-uncalled-villain', '0.00');
		      setText('call-amount', '0.00');
		      setText('pot-call', '0.00');
		      setText('call-uncalled-villain', '0.00');
		      setText('fold-ev', '0.00');
		      setText('win-ev', '0.00');
		      setText('lose-ev', '0.00');
		      setText('required-winrate', '0.00%');

	      const assumedDiv = document.getElementById('assumed-ev');
	      if (assumedDiv) assumedDiv.classList.remove('active');
	      setText('assumed-call-ev', '0.00');
	      setText('assumed-ev-diff', '0.00');

	      const breakdownDiv = document.getElementById('icm-breakdown');
	      if (breakdownDiv) breakdownDiv.innerHTML = '';
	      const evListDiv = document.getElementById('ev-list');
	      if (evListDiv) evListDiv.innerHTML = '';
	    }

	    function updateAssumedEvDisplay() {
	      const assumedDiv = document.getElementById('assumed-ev');
	      const assumedInput = document.getElementById('assumed-winrate');
	      if (!assumedDiv || !assumedInput || !lastIcmResult) return;

	      const str = assumedInput.value.trim();
	      if (str === '') {
	        assumedDiv.classList.remove('active');
	        return;
	      }
	      const pct = parseFloat(str);
	      if (!Number.isFinite(pct) || pct < 0 || pct > 100) {
	        assumedDiv.classList.remove('active');
	        return;
	      }

	      const p = pct / 100;
	      const callEV = p * lastIcmResult.winEV + (1 - p) * lastIcmResult.loseEV;
	      const diff = callEV - lastIcmResult.foldEV;

	      const callEvSpan = document.getElementById('assumed-call-ev');
	      const diffSpan = document.getElementById('assumed-ev-diff');
	      callEvSpan.textContent = callEV.toFixed(2);
	      diffSpan.textContent = (diff >= 0 ? '+' : '') + diff.toFixed(2);
	      diffSpan.classList.remove('ev-positive', 'ev-negative');
	      diffSpan.classList.add(diff >= 0 ? 'ev-positive' : 'ev-negative');

	      assumedDiv.classList.add('active');
	    }

	    function setIcmError(message) {
	      console.error(message);
	      resetIcmOutputs();
	      const errorDiv = document.getElementById('icm-error');
	      errorDiv.textContent = message;
	      errorDiv.classList.add('active');
	    }

    function clearIcmError() {
      const errorDiv = document.getElementById('icm-error');
      errorDiv.textContent = '';
      errorDiv.classList.remove('active');
    }

	    function findUniquePositionIndex(positions, targetValue, targetLabel) {
	      const indices = [];
	      for (let i = 0; i < positions.length; i++) {
	        if (positions[i] === targetValue) indices.push(i);
	      }
	      if (indices.length === 0) return { index: -1, error: null };
	      if (indices.length === 1) return { index: indices[0], error: null };
	      const players = indices.map(i => formatPlayerLabel(i)).join(', ');
	      return { index: -1, error: `${targetLabel} が複数選択されています: ${players}` };
	    }

    function createIcmHandState(stacks) {
      return {
        remaining: stacks.slice(),
        betContributed: new Array(stacks.length).fill(0),
        deadContributed: new Array(stacks.length).fill(0),
        pot: 0,
        folded: new Array(stacks.length).fill(false),
      };
    }

    function payDeadChips(state, playerIndex, amount) {
      if (playerIndex < 0) return 0;
      if (!Number.isFinite(amount) || amount <= 0) return 0;
      const paid = Math.max(0, Math.min(amount, state.remaining[playerIndex]));
      state.remaining[playerIndex] -= paid;
      state.deadContributed[playerIndex] += paid;
      state.pot += paid;
      return paid;
    }

    function payBetChips(state, playerIndex, amount) {
      if (playerIndex < 0) return 0;
      if (!Number.isFinite(amount) || amount <= 0) return 0;
      const paid = Math.max(0, Math.min(amount, state.remaining[playerIndex]));
      state.remaining[playerIndex] -= paid;
      state.betContributed[playerIndex] += paid;
      state.pot += paid;
      return paid;
    }

    function betToTotalBetContribution(state, playerIndex, targetTotal) {
      if (playerIndex < 0) return 0;
      if (!Number.isFinite(targetTotal) || targetTotal <= 0) return 0;
      const current = state.betContributed[playerIndex];
      const need = targetTotal - current;
      if (need <= 0) return 0;
      return payBetChips(state, playerIndex, need);
    }

    function betAllIn(state, playerIndex) {
      if (playerIndex < 0) return 0;
      return payBetChips(state, playerIndex, state.remaining[playerIndex]);
    }

    function getTotalContributions(betContributions, deadContributions) {
      return betContributions.map((v, i) => v + (deadContributions[i] || 0));
    }

    function describeIcmAction(action) {
      const player = formatPlayerLabel(action.playerIndex);
      if (action.type === 'postAnte') {
        return `${player} ${action.label} ${action.amount.toFixed(2)}`;
      }
      if (action.type === 'postBlind') {
        return `${player} ${action.label} ${action.amount.toFixed(2)}`;
      }
      if (action.type === 'raiseTo') {
        return `${player} レイズ to ${action.toAmount.toFixed(2)}`;
      }
      if (action.type === 'allIn') {
        return Number.isFinite(action.toAmount) ? `${player} オールイン to ${action.toAmount.toFixed(2)}` : `${player} オールイン`;
      }
      if (action.type === 'callTo') {
        return `${player} コール to ${action.toAmount.toFixed(2)}`;
      }
      if (action.type === 'fold') {
        return `${player} フォールド`;
      }
      return `${player} ${action.type}`;
    }

    function applyIcmActions(initialStacks, actions) {
      const state = createIcmHandState(initialStacks);
      const log = [];

      for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const playerIndex = action.playerIndex;
        if (!Number.isFinite(playerIndex) || playerIndex < 0 || playerIndex >= initialStacks.length) {
          return { error: `プレイヤー指定が不正です: ${playerIndex}` };
        }
        if (state.folded[playerIndex] && action.type !== 'postAnte' && action.type !== 'postBlind') {
          return { error: `${formatPlayerLabel(playerIndex)} はすでにフォールドしています` };
        }

        let paid = 0;
        if (action.type === 'postAnte') {
          paid = payDeadChips(state, playerIndex, action.amount);
        } else if (action.type === 'postBlind') {
          paid = payBetChips(state, playerIndex, action.amount);
        } else if (action.type === 'raiseTo' || action.type === 'callTo') {
          paid = betToTotalBetContribution(state, playerIndex, action.toAmount);
        } else if (action.type === 'allIn') {
          paid = betAllIn(state, playerIndex);
        } else if (action.type === 'fold') {
          state.folded[playerIndex] = true;
          paid = 0;
        } else {
          return { error: `未対応のアクションです: ${action.type}` };
        }

        log.push({
          step: i + 1,
          desc: describeIcmAction(action),
          paid,
          pot: state.pot,
        });
      }

      const betContributions = state.betContributed.slice();
      const deadContributions = state.deadContributed.slice();
      return {
        betContributions,
        deadContributions,
        totalContributions: getTotalContributions(betContributions, deadContributions),
        remaining: state.remaining.slice(),
        folded: state.folded.slice(),
        pot: state.pot,
        log,
      };
    }

	    function sumNumbers(values) {
	      let total = 0;
	      for (const v of values) total += v;
	      return total;
	    }

		    function computeUncalledRefunds(betContributions, folded) {
		      const n = betContributions.length;
		      if (!Array.isArray(folded) || folded.length !== n) return { refunds: [], error: 'フォールド配列の長さが不正です' };

		      const refunds = new Array(n).fill(0);
		      for (let i = 0; i < n; i++) {
		        const bet = betContributions[i];
		        if (!Number.isFinite(bet) || bet < 0) return { refunds: [], error: 'ベット投入額が不正です' };
		        if (folded[i]) continue;
		
		        let maxOtherBet = 0;
		        for (let j = 0; j < n; j++) {
		          if (j === i) continue;
		          if (folded[j]) continue;
		          const other = betContributions[j];
		          if (!Number.isFinite(other) || other < 0) return { refunds: [], error: 'ベット投入額が不正です' };
		          if (other > maxOtherBet) maxOtherBet = other;
		        }
		
		        const refundRaw = bet - maxOtherBet;
		        if (!Number.isFinite(refundRaw)) return { refunds: [], error: '未コール返却が不正です' };
		        refunds[i] = refundRaw <= 0 ? 0 : refundRaw;
		      }
		
		      return { refunds, error: null };
		    }

	    function buildIcmOutcomeStacks(postActionResult, uncalledRefunds, potAwarded, winnerIndex) {
	      const n = postActionResult.remaining.length;
	      if (uncalledRefunds.length !== n) return { error: '未コール返却配列の長さが不正です' };
	      if (!Number.isFinite(potAwarded) || potAwarded < 0) return { error: 'ポット額が不正です' };
      if (!Number.isFinite(winnerIndex) || winnerIndex < 0 || winnerIndex >= n) return { error: 'winnerIndex が不正です' };

      const stacks = postActionResult.remaining.slice();
      for (let i = 0; i < n; i++) {
        const r = uncalledRefunds[i];
        if (!Number.isFinite(r) || r < 0) return { error: '未コール返却が不正です' };
        stacks[i] += r;
      }
      stacks[winnerIndex] += potAwarded;
      return { stacks };
    }

    function renderIcmBreakdown({ preLog, callPot, foldRefunds, callRefunds, heroIndex, allinIndex }) {
      const breakdownDiv = document.getElementById('icm-breakdown');
      if (!breakdownDiv) return;

      const actionRows = preLog.map(row => `
        <tr>
          <td>${row.step}</td>
          <td>${row.desc}</td>
          <td>${row.paid.toFixed(2)}</td>
          <td>${row.pot.toFixed(2)}</td>
        </tr>
      `).join('');

      const formatRefunds = (refunds) => {
        const parts = [];
        for (let i = 0; i < refunds.length; i++) {
          if (refunds[i] > 1e-9) parts.push(`${formatPlayerLabel(i)}: ${refunds[i].toFixed(2)}`);
        }
        return parts.length === 0 ? '-' : parts.join(' / ');
      };

      breakdownDiv.innerHTML = `
        <div class="icm-section-title">アクション(コール前)</div>
        <table>
          <thead>
            <tr><th>#</th><th>内容</th><th>支払い</th><th>ポット合計</th></tr>
          </thead>
          <tbody>${actionRows || '<tr><td colspan="4">-</td></tr>'}</tbody>
        </table>

	        <div class="icm-section-title">ショーダウンポット(コール時)</div>
        <table>
          <tbody>
            <tr><th>金額</th><td>${Number.isFinite(callPot) ? callPot.toFixed(2) : '-'}</td></tr>
            <tr><th>勝利対象</th><td>${formatPlayerLabel(heroIndex)} / ${formatPlayerLabel(allinIndex)}</td></tr>
          </tbody>
        </table>

        <div class="icm-section-title">未コール返却(フォールド時/コール時)</div>
        <table>
          <tbody>
            <tr><th>フォールド時</th><td>${formatRefunds(foldRefunds)}</td></tr>
            <tr><th>コール時</th><td>${formatRefunds(callRefunds)}</td></tr>
          </tbody>
        </table>
      `;
    }

    function readIcmBbAnte() {
      const anteInput = document.getElementById('bb-ante');
      if (!anteInput) return { value: 0, error: null };
      const str = anteInput.value.trim();
      if (str === '') return { value: 0, error: null };
      const value = parseFloat(str);
      if (!Number.isFinite(value) || value < 0) return { value: 0, error: `BBアンティが不正です: ${str}` };
      return { value, error: null };
    }

    function readIcmPreAllInActions(n) {
      const tbody = document.getElementById('icm-action-rows');
      if (!tbody) return { actions: [], error: null };
      const rows = Array.from(tbody.querySelectorAll('tr'));

      const actions = [];
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const step = i + 1;
        const playerEl = row.querySelector('.icm-action-player');
        const typeEl = row.querySelector('.icm-action-type');
        const toEl = row.querySelector('.icm-action-to');
        if (!playerEl || !typeEl) return { actions: [], error: `アクション#${step}: 入力行が不正です` };

        const playerIndexRaw = playerEl.value;
        const playerIndex = parseInt(playerIndexRaw);
        if (!Number.isFinite(playerIndex) || playerIndex < 0 || playerIndex >= n) {
          return { actions: [], error: `アクション#${step}: プレイヤーが不正です: ${playerIndexRaw}` };
        }

        const type = typeEl.value;
        if (type === 'fold') {
          actions.push({ type: 'fold', playerIndex });
          continue;
        }
        if (type !== 'raiseTo' && type !== 'callTo') {
          return { actions: [], error: `アクション#${step}: アクション種別が不正です: ${type}` };
        }

        const toStr = (toEl ? toEl.value : '').trim();
        if (toStr === '') {
          return { actions: [], error: `アクション#${step}: 金額(to)を入力してください` };
        }
        const toAmount = parseFloat(toStr);
        if (!Number.isFinite(toAmount) || toAmount <= 0) {
          return { actions: [], error: `アクション#${step}: 金額(to)が不正です: ${toStr}` };
        }
        actions.push({ type, playerIndex, toAmount });
      }

      return { actions, error: null };
    }

	    function renderIcmPlayerActionSummary() {
	      refreshIcmCallToAutoValues();
	      const n = parseInt(document.getElementById('num-players').value);
	      const positions = [];
      for (let i = 0; i < n; i++) {
        const posEl = document.getElementById(`pos${i}`);
        positions.push(posEl ? posEl.value : 'none');
      }
      const sbIndex = positions.indexOf('sb');
      const bbIndex = positions.indexOf('bb');

      const bbAnte = readIcmBbAnte();
      const anteValue = bbAnte.error ? 0 : bbAnte.value;

      const histories = new Array(n).fill(null).map(() => []);
      if (bbIndex !== -1 && anteValue > 0) histories[bbIndex].push(`BBアンティ ${anteValue.toFixed(2)}`);
      if (sbIndex !== -1) histories[sbIndex].push('SB 0.50');
      if (bbIndex !== -1) histories[bbIndex].push('BB 1.00');

      const pre = readIcmPreAllInActions(n);
      if (!pre.error) {
        for (const action of pre.actions) {
          const p = action.playerIndex;
          if (action.type === 'fold') histories[p].push('フォールド');
          if (action.type === 'raiseTo') histories[p].push(`レイズ to ${action.toAmount.toFixed(2)}`);
          if (action.type === 'callTo') histories[p].push(`コール to ${action.toAmount.toFixed(2)}`);
        }
      }

      const allinIndexStr = document.getElementById('allin-index')?.value;
      const allinIndex = allinIndexStr === undefined ? NaN : parseInt(allinIndexStr);
      if (Number.isFinite(allinIndex) && allinIndex >= 0 && allinIndex < n) {
        histories[allinIndex].push('オールイン(自動)');
      }

	      for (let i = 0; i < n; i++) {
	        const cell = document.getElementById(`icm-player-action${i}`);
	        if (!cell) continue;
	        cell.textContent = histories[i].length === 0 ? '-' : histories[i].join(' → ');
	      }
	      renderIcmTableVisual();
	    }

	    function calculateICM() {
	      const n = parseInt(document.getElementById('num-players').value);
	      clearIcmError();
	      resetIcmOutputs();
	      refreshIcmCallToAutoValues();

	      const stacks = [];
      const prizes = [];
      const positions = [];

      for (let i = 0; i < n; i++) {
        const stackStr = document.getElementById(`stack${i}`).value.trim();
        if (stackStr === '') {
          setIcmError(`${formatPlayerLabel(i)} のスタックを入力してください`);
          return;
        }
        const stack = parseFloat(stackStr);
        if (!Number.isFinite(stack) || stack < 0) {
          setIcmError(`${formatPlayerLabel(i)} のスタックが不正です: ${stackStr}`);
          return;
        }
        stacks.push(stack);

        const prizeStr = document.getElementById(`prize${i}`).value.trim();
        const prize = prizeStr === '' ? 0 : parseFloat(prizeStr);
        if (!Number.isFinite(prize) || prize < 0) {
          setIcmError(`${formatPlayerLabel(i)} のプライズが不正です: ${prizeStr}`);
          return;
        }
        prizes.push(prize);

        const posEl = document.getElementById(`pos${i}`);
        positions.push(posEl ? posEl.value : 'none');
      }

      const bbAnte = readIcmBbAnte();
      if (bbAnte.error) {
        setIcmError(bbAnte.error);
        return;
      }

      const heroIndex = parseInt(document.getElementById('hero-index').value);
      const allinIndex = parseInt(document.getElementById('allin-index').value);
      if (!Number.isFinite(heroIndex) || heroIndex < 0 || heroIndex >= n) {
        setIcmError(`ヒーローが不正です: ${document.getElementById('hero-index').value}`);
        return;
      }
      if (!Number.isFinite(allinIndex) || allinIndex < 0 || allinIndex >= n) {
        setIcmError(`オールイン相手が不正です: ${document.getElementById('allin-index').value}`);
        return;
      }
      if (heroIndex === allinIndex) {
        setIcmError('ヒーローとオールイン相手が同一です');
        return;
      }
      if (stacks[heroIndex] === 0) {
        setIcmError('ヒーローのスタックが 0 です');
        return;
      }
      if (stacks[allinIndex] === 0) {
        setIcmError('オールイン相手のスタックが 0 です');
        return;
      }

      const sb = findUniquePositionIndex(positions, 'sb', 'SB');
      if (sb.error) {
        setIcmError(sb.error);
        return;
      }
      const bb = findUniquePositionIndex(positions, 'bb', 'BB');
      if (bb.error) {
        setIcmError(bb.error);
        return;
      }
      if (sb.index === -1 || bb.index === -1) {
        setIcmError('SB と BB をそれぞれ 1人ずつ選択してください');
        return;
      }
      if (sb.index === bb.index) {
        setIcmError('SB と BB が同一プレイヤーです');
        return;
      }

	      addIcmFoldOthers();
	      clearIcmError();
	      const preUserActions = readIcmPreAllInActions(n);
	      if (preUserActions.error) {
	        setIcmError(preUserActions.error);
	        return;
	      }

      const forcedActions = [];
      if (bbAnte.value > 0) {
        forcedActions.push({ type: 'postAnte', playerIndex: bb.index, amount: bbAnte.value, label: 'BBアンティ' });
      }
      forcedActions.push({ type: 'postBlind', playerIndex: sb.index, amount: 0.5, label: 'SB' });
      forcedActions.push({ type: 'postBlind', playerIndex: bb.index, amount: 1.0, label: 'BB' });

      const eps = 1e-9;
      const validateState = createIcmHandState(stacks);
      if (bbAnte.value > 0) payDeadChips(validateState, bb.index, bbAnte.value);
      payBetChips(validateState, sb.index, 0.5);
      payBetChips(validateState, bb.index, 1.0);

      const currentBets = validateState.betContributed;
      let currentBetTo = 0;
      for (const v of currentBets) if (v > currentBetTo) currentBetTo = v;

      if (validateState.remaining[heroIndex] <= eps) {
        setIcmError('ヒーローがブラインド/アンティでオールインになっています');
        return;
      }
      if (validateState.remaining[allinIndex] <= eps) {
        setIcmError('オールイン相手がブラインド/アンティでオールインになっています');
        return;
      }

	      for (let i = 0; i < preUserActions.actions.length; i++) {
	        const action = preUserActions.actions[i];
	        const step = i + 1;
	        const p = action.playerIndex;

	        if (p === allinIndex) {
	          setIcmError('オールイン相手はこの後自動オールインします。オールイン前アクションには追加できません（空欄でもOK）');
	          return;
	        }

	        if (validateState.folded[p]) {
	          setIcmError(`アクション#${step}: ${formatPlayerLabel(p)} はすでにフォールドしています`);
	          return;
	        }
	        if (p === heroIndex && action.type === 'fold') {
	          setIcmError(`アクション#${step}: ヒーローをフォールドさせる入力はできません`);
	          return;
	        }
	        if (validateState.remaining[p] <= eps && action.type !== 'fold') {
	          setIcmError(`アクション#${step}: ${formatPlayerLabel(p)} はすでにオールインしています`);
	          return;
	        }

        if (action.type === 'fold') {
          validateState.folded[p] = true;
          continue;
        }

        const toAmount = action.toAmount;
        if (!Number.isFinite(toAmount) || toAmount <= 0) {
          setIcmError(`アクション#${step}: 金額(to)が不正です`);
          return;
        }

        const maxBet = validateState.betContributed[p] + validateState.remaining[p];
        if (toAmount > maxBet + eps) {
          setIcmError(`アクション#${step}: ${formatPlayerLabel(p)} のスタックを超えています (最大to=${maxBet.toFixed(2)})`);
          return;
        }

        if (action.type === 'callTo') {
          if (Math.abs(toAmount - currentBetTo) > 1e-6) {
            setIcmError(`アクション#${step}: コールto は現在のベット額(${currentBetTo.toFixed(2)})に合わせてください`);
            return;
          }
          betToTotalBetContribution(validateState, p, currentBetTo);
        } else if (action.type === 'raiseTo') {
          if (toAmount <= currentBetTo + eps) {
            setIcmError(`アクション#${step}: レイズto は現在のベット額(${currentBetTo.toFixed(2)})より大きくしてください`);
            return;
          }
          betToTotalBetContribution(validateState, p, toAmount);
          if (validateState.betContributed[p] > currentBetTo) currentBetTo = validateState.betContributed[p];
        } else {
          setIcmError(`アクション#${step}: 未対応のアクションです: ${action.type}`);
          return;
        }

	        if (validateState.remaining[p] <= eps) {
	          setIcmError(`アクション#${step}: この入力だと ${formatPlayerLabel(p)} がオールインになります。金額(to)を下げるかフォールドを選んでください`);
	          return;
	        }
	      }

      if (validateState.folded[allinIndex]) {
        setIcmError('オールイン相手がフォールドしています');
        return;
      }
      if (validateState.remaining[allinIndex] <= eps) {
        setIcmError('オールイン相手がすでにオールインしています (オールイン前アクションでスタックが0になっています)');
        return;
      }

      const allinTo = validateState.betContributed[allinIndex] + validateState.remaining[allinIndex];
      const actionsToAllIn = forcedActions.concat(preUserActions.actions, [{
        type: 'allIn',
        playerIndex: allinIndex,
        toAmount: allinTo
      }]);
      const preToAllIn = applyIcmActions(stacks, actionsToAllIn);
      if (preToAllIn.error) {
        setIcmError(preToAllIn.error);
        return;
      }

      const postAllInFolds = [];
      for (let i = 0; i < n; i++) {
        if (i === heroIndex || i === allinIndex) continue;
        if (stacks[i] <= eps) continue;
        if (preToAllIn.folded[i]) continue;
        if (preToAllIn.remaining[i] <= eps) {
          setIcmError(`${formatPlayerLabel(i)} がオールイン後にアクション可能な状態です。ブラインド/アンティ等で第3者がオールインしている構成は、このツールの2人ショーダウン前提外です。`);
          return;
        }
        postAllInFolds.push({ type: 'fold', playerIndex: i });
      }

      const actions = actionsToAllIn.concat(postAllInFolds);
      const pre = applyIcmActions(stacks, actions);
      if (pre.error) {
        setIcmError(pre.error);
        return;
      }

	      const heroMaxBet = pre.betContributions[heroIndex] + pre.remaining[heroIndex];
	      const villainMaxBet = pre.betContributions[allinIndex];
	      const callTo = Math.min(heroMaxBet, villainMaxBet);
	      const callAmount = Math.max(0, callTo - pre.betContributions[heroIndex]);

      const callActions = actions.concat([{ type: 'callTo', playerIndex: heroIndex, toAmount: callTo }]);
	      const called = applyIcmActions(stacks, callActions);
	      if (called.error) {
	        setIcmError(called.error);
	        return;
	      }

	      const epsRefund = 1e-9;

	      const foldEndFolded = pre.folded.slice();
	      foldEndFolded[heroIndex] = true;
	      const foldRefundCalc = computeUncalledRefunds(pre.betContributions, foldEndFolded);
	      if (foldRefundCalc.error) {
	        setIcmError(`フォールド時: ${foldRefundCalc.error}`);
	        return;
	      }
	      const foldRefunds = foldRefundCalc.refunds;
	      const foldPot = pre.pot - sumNumbers(foldRefunds);
	      if (!Number.isFinite(foldPot) || foldPot < -epsRefund) {
	        setIcmError('フォールド時ポット額が不正です');
	        return;
	      }

	      const callRefundCalc = computeUncalledRefunds(called.betContributions, called.folded);
	      if (callRefundCalc.error) {
	        setIcmError(`コール時: ${callRefundCalc.error}`);
	        return;
	      }
	      const callRefunds = callRefundCalc.refunds;
	      const callPot = called.pot - sumNumbers(callRefunds);
	      if (!Number.isFinite(callPot) || callPot < -epsRefund) {
	        setIcmError('コール後ポット額が不正です');
	        return;
	      }

	      const foldOutcome = buildIcmOutcomeStacks(pre, foldRefunds, foldPot, allinIndex);
      if (foldOutcome.error) {
        setIcmError(foldOutcome.error);
        return;
      }
      const winOutcome = buildIcmOutcomeStacks(called, callRefunds, callPot, heroIndex);
      if (winOutcome.error) {
        setIcmError(winOutcome.error);
        return;
      }
      const loseOutcome = buildIcmOutcomeStacks(called, callRefunds, callPot, allinIndex);
      if (loseOutcome.error) {
        setIcmError(loseOutcome.error);
        return;
      }

      const foldEV = computeICMRecursive(foldOutcome.stacks, prizes)[heroIndex];
      const winEV = computeICMRecursive(winOutcome.stacks, prizes)[heroIndex];
      const loseEV = computeICMRecursive(loseOutcome.stacks, prizes)[heroIndex];

      const denom = winEV - loseEV;
      if (denom === 0) {
        setIcmError('必要勝率を算出できません (winEV と loseEV が同一です)');
        return;
      }
	      const requiredPct = (foldEV - loseEV) / denom * 100;

	      document.getElementById('effective-stack').textContent = callTo.toFixed(2);
	      document.getElementById('villain-allin-to').textContent = pre.betContributions[allinIndex].toFixed(2);
	      document.getElementById('pot-fold').textContent = foldPot.toFixed(2);
	      document.getElementById('fold-uncalled-villain').textContent = foldRefunds[allinIndex].toFixed(2);
	      document.getElementById('call-amount').textContent = callAmount.toFixed(2);
	      document.getElementById('pot-call').textContent = callPot.toFixed(2);
	      document.getElementById('call-uncalled-villain').textContent = callRefunds[allinIndex].toFixed(2);
	      document.getElementById('fold-ev').textContent = foldEV.toFixed(2);
	      document.getElementById('win-ev').textContent = winEV.toFixed(2);
	      document.getElementById('lose-ev').textContent = loseEV.toFixed(2);
	      document.getElementById('required-winrate').textContent = requiredPct.toFixed(2) + '%';

      lastIcmResult = { heroIndex, foldEV, winEV, loseEV };
      updateAssumedEvDisplay();

      renderIcmBreakdown({
        preLog: pre.log,
        callPot,
        foldRefunds,
        callRefunds,
        heroIndex,
        allinIndex,
      });

      const allEV = computeICMRecursive(stacks, prizes);
      const evListDiv = document.getElementById('ev-list');
      evListDiv.innerHTML = '開始時ICM:<br>';
      allEV.forEach((val, idx) => {
        evListDiv.innerHTML += `${formatPlayerLabel(idx)}: ${val.toFixed(2)}<br>`;
      });
    }

    function computeICMRecursive(stacks, prizes) {
      const n = stacks.length;
      const payouts = prizes.slice();
      while (payouts.length < n) {
        payouts.push(0);
      }
      const results = new Array(n).fill(0);

      function recurse(activeIndices, remainingPayouts, probFactor) {
        const m = activeIndices.length;
        if (m === 0) return;
        if (m === 1) {
          const playerIndex = activeIndices[0];
          results[playerIndex] += probFactor * (remainingPayouts[0] || 0);
          return;
        }
        let totalChips = 0;
        activeIndices.forEach(idx => {
          totalChips += stacks[idx];
        });
        const topPrize = remainingPayouts[0] || 0;
        for (let j = 0; j < m; j++) {
          const playerIndex = activeIndices[j];
          const chips = stacks[playerIndex];
          const p = (totalChips > 0 ? chips / totalChips : 0);
          results[playerIndex] += probFactor * p * topPrize;
          const newActive = activeIndices.slice(0, j).concat(activeIndices.slice(j+1));
          recurse(newActive, remainingPayouts.slice(1), probFactor * p);
        }
      }

      const initialIndices = stacks.map((_, idx) => idx);
      recurse(initialIndices, payouts, 1);
      return results;
    }
    
	    // イベントリスナーの設定
		    document.addEventListener('DOMContentLoaded', () => {
	      // レンジグリッド生成
	      generateRangeGrid();
	      setupRangePointerInteractions();
	      refreshSavedRangeOptions();

	      // 初期設定読み込み
	      const settings = readAppSettings();
	      const hasSavedSettings = hasStoredAppSettings();
	      const preferFastByViewport = !hasSavedSettings
	        && typeof window.matchMedia === 'function'
	        && window.matchMedia('(max-width: 430px)').matches;
	      const initialMode = preferFastByViewport ? 'fast' : settings.mode;
	      applyRangeZoomClass(settings.zoom);
	      const defaultModeSelect = document.getElementById('default-mode-select');
	      if (defaultModeSelect) defaultModeSelect.value = initialMode;
	      const defaultZoomSelect = document.getElementById('default-zoom-select');
	      if (defaultZoomSelect) defaultZoomSelect.value = settings.zoom;
	      applyCalcMode(initialMode);
	      const currentUrl = window.location.href;
	      const currentUrlEl = document.getElementById('settings-current-url');
	      const workspaceWarningEl = document.getElementById('workspace-warning');
	      if (currentUrlEl) currentUrlEl.textContent = currentUrl;
	      if (workspaceWarningEl) {
	        const isUnsafeWorkspace = /OneDrive|popker_backup|ARCHIVE|DO_NOT_USE/i.test(currentUrl);
	        workspaceWarningEl.textContent = isUnsafeWorkspace ? 'それはバックアップ/隔離コピー。正規は C:\\repos\\popker を開け' : '';
	        workspaceWarningEl.classList.toggle('active', isUnsafeWorkspace);
	      }

	      trainerHistory = loadTrainerHistory();
	      renderTrainerHistory();
	      renderTrainerStats();
	      drawTrainerQuestion();
	      setHudHeroCards();
	      updateRangeCountDisplay();
	      updateEquityPrecalcDisplay();
		      
	      // カードクリックイベント
	      document.querySelectorAll('#card-grid td').forEach(cell => {
	        cell.addEventListener('click', handleCardClick);
	      });
	      
	      // レンジクリックイベント
	      document.querySelectorAll('#range-grid td').forEach(cell => {
	        cell.addEventListener('click', (e) => {
	          if (isRangePointerDown) return;
	          if (performance.now() < rangeSuppressClickUntil) return;
	          handleRangeClick(e);
	        });
	      });
	      
	      // 計算ボタン
	      document.getElementById('calc-winrate-btn').addEventListener('click', calculateWinRate);
	      document.getElementById('sample-count').addEventListener('change', updateEquityPrecalcDisplay);
	      document.getElementById('calc-mode').addEventListener('change', (e) => {
	        applyCalcMode(e.target.value, true);
	        clearComputedEquityDisplays();
	      });
	      document.getElementById('cancel-winrate-btn').addEventListener('click', () => {
	        winrateCancelRequested = true;
	        const btn = document.getElementById('cancel-winrate-btn');
	        if (!btn) return;
	        btn.disabled = true;
	        btn.textContent = 'キャンセル中...';
	      });
	      document.getElementById('zoom-sm-btn').addEventListener('click', () => applyRangeZoomClass('zoom-sm'));
	      document.getElementById('zoom-md-btn').addEventListener('click', () => applyRangeZoomClass('zoom-md'));
	      document.getElementById('zoom-lg-btn').addEventListener('click', () => applyRangeZoomClass('zoom-lg'));

	      document.getElementById('save-range-btn').addEventListener('click', saveCurrentRange);
	      document.getElementById('load-range-btn').addEventListener('click', loadSelectedRange);
	      document.getElementById('delete-range-btn').addEventListener('click', deleteSelectedRange);
	      document.getElementById('range-export-btn').addEventListener('click', exportRangeJson);
	      document.getElementById('range-import-btn').addEventListener('click', importRangeJson);

	      document.getElementById('evbet-set-third').addEventListener('click', () => setEvBetByPotRatio(1 / 3));
	      document.getElementById('evbet-set-half').addEventListener('click', () => setEvBetByPotRatio(1 / 2));
	      document.getElementById('evbet-set-two-third').addEventListener('click', () => setEvBetByPotRatio(2 / 3));
	      document.getElementById('evbet-set-pot').addEventListener('click', () => setEvBetByPotRatio(1));
	      document.getElementById('evcalc-calc-bet-btn').addEventListener('click', updateBetEvDecision);


		      document.getElementById('trainer-new-btn').addEventListener('click', drawTrainerQuestion);
		      document.getElementById('trainer-check-btn').addEventListener('click', checkTrainerAnswer);
		      const trainerSessionModeSelect = document.getElementById('trainer-session-mode');
		      if (trainerSessionModeSelect) {
		        trainerSessionModeSelect.addEventListener('change', resetTrainerSessionState);
		      }
		      const trainerTimeLimitInput = document.getElementById('trainer-time-limit-sec');
		      if (trainerTimeLimitInput) {
		        trainerTimeLimitInput.addEventListener('change', () => {
		          if (readTrainerSessionMode() === 'drill') resetTrainerSessionState();
		        });
		      }
		      document.getElementById('run-ev-selftest-btn').addEventListener('click', runEvCalculatorSelfTests);

	      document.getElementById('save-settings-btn').addEventListener('click', () => {
	        saveAppSettings();
	        const saved = readAppSettings();
	        applyRangeZoomClass(saved.zoom);
	        applyCalcMode(saved.mode, true);
	      });
	      if (defaultZoomSelect) {
	        defaultZoomSelect.addEventListener('change', (e) => applyRangeZoomClass(e.target.value));
	      }
	      if (defaultModeSelect) {
	        defaultModeSelect.addEventListener('change', (e) => applyCalcMode(e.target.value, true));
	      }

	      document.querySelectorAll('#bottom-nav .nav-btn').forEach(btn => {
	        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
	      });
      const initialTab = new URLSearchParams(window.location.search).get('tab');
      if (initialTab && document.getElementById(initialTab)) switchTab(initialTab);
      if (window.location.hash === '#icm-table-panel') {
        requestAnimationFrame(() => jumpToIcmTablePanel('initial-hash'));
      }

	      // ICM関連
	      generatePlayerInputs();
	      renderIcmTableVisual();
      document.getElementById('generate-btn').addEventListener('click', generatePlayerInputs);
      document.getElementById('jump-icm-table-btn').addEventListener('click', () => jumpToIcmTablePanel('button'));
      document.getElementById('calc-icm-btn').addEventListener('click', calculateICM);
	      document.getElementById('icm-drill-start-btn').addEventListener('click', startIcmDrillQuestion);
	      document.getElementById('icm-drill-call-btn').addEventListener('click', () => submitIcmDrillAnswer(true));
	      document.getElementById('icm-drill-fold-btn').addEventListener('click', () => submitIcmDrillAnswer(false));
      document.getElementById('hero-index').addEventListener('change', () => {
        rebuildIcmPlayerSelectOptions(document.getElementById('hero-index'), parseInt(document.getElementById('num-players').value));
        rebuildIcmPlayerSelectOptions(document.getElementById('allin-index'), parseInt(document.getElementById('num-players').value));
        updateIcmPlayerHighlights();
        renderIcmPlayerActionSummary();
	        resetIcmDrillQuestion('座席条件を変更しました。必要なら再出題してください。');
      });
	      document.getElementById('allin-index').addEventListener('change', () => {
	        rebuildIcmPlayerSelectOptions(document.getElementById('hero-index'), parseInt(document.getElementById('num-players').value));
	        rebuildIcmPlayerSelectOptions(document.getElementById('allin-index'), parseInt(document.getElementById('num-players').value));
	        refreshIcmActionPlayerOptionTexts();
	        updateIcmPlayerHighlights();
	        renderIcmPlayerActionSummary();
	        resetIcmDrillQuestion('座席条件を変更しました。必要なら再出題してください。');
	      });
	      document.getElementById('bb-ante').addEventListener('input', renderIcmPlayerActionSummary);

	      document.getElementById('add-icm-action-btn').addEventListener('click', () => addIcmActionRow());
	      document.getElementById('fold-others-icm-action-btn').addEventListener('click', addIcmFoldOthers);
	      document.getElementById('clear-icm-action-btn').addEventListener('click', clearIcmActionRows);

      const actionRowsTbody = document.getElementById('icm-action-rows');
	      actionRowsTbody.addEventListener('click', (e) => {
	        const btn = e.target.closest('.icm-remove-action-btn');
	        if (!btn) return;
	        const row = btn.closest('tr');
	        if (!row) return;
	        row.remove();
	        updateIcmActionRowNumbers();
	        refreshIcmCallToAutoValues();
	        renderIcmPlayerActionSummary();
	      });
	      actionRowsTbody.addEventListener('change', (e) => {
	        const row = e.target.closest('tr');
	        if (!row) return;
	        if (e.target.classList.contains('icm-action-type')) {
	          setIcmActionRowAmountMode(row);
	          refreshIcmCallToAutoValues();
	        }
	        if (e.target.classList.contains('icm-action-player') || e.target.classList.contains('icm-action-type')) {
	          renderIcmPlayerActionSummary();
	        }
	      });
	      actionRowsTbody.addEventListener('input', (e) => {
	        if (e.target.classList.contains('icm-action-to')) {
	          refreshIcmCallToAutoValues();
	          renderIcmPlayerActionSummary();
	        }
	      });

	      const playerInputsDiv = document.getElementById('player-inputs');
	      playerInputsDiv.addEventListener('change', (e) => {
	        if (!e.target || !e.target.id) return;
	        if (e.target.id.startsWith('stack') || e.target.id.startsWith('prize')) {
	          renderIcmTableVisual();
	          resetIcmDrillQuestion('テーブル入力を変更しました。必要なら再出題してください。');
	          return;
	        }
	        if (!e.target.id.startsWith('pos')) return;
        const playerCount = parseInt(document.getElementById('num-players').value);
        rebuildIcmPlayerSelectOptions(document.getElementById('hero-index'), playerCount);
        rebuildIcmPlayerSelectOptions(document.getElementById('allin-index'), playerCount);
	        refreshIcmActionPlayerOptionTexts();
	        updateIcmPlayerHighlights();
	        renderIcmPlayerActionSummary();
	        resetIcmDrillQuestion('ポジションを変更しました。必要なら再出題してください。');
	      });
	      playerInputsDiv.addEventListener('input', (e) => {
	        if (!e.target || !e.target.id) return;
	        if (!e.target.id.startsWith('stack') && !e.target.id.startsWith('prize')) return;
	        renderIcmTableVisual();
	      });
	    });
  </script>
</body>
</html>
