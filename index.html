<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Poker Equity Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* モバイル対応 */
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      .container {
        padding: 10px;
        border-radius: 0;
      }
      h1 {
        font-size: 1.5em;
      }
      h2 {
        font-size: 1.2em;
      }
    }
    
    .tab-menu {
      display: flex;
      list-style: none;
      padding: 0;
      margin: 0 0 20px 0;
      border-bottom: 2px solid #ddd;
      overflow-x: auto;
    }
    .tab-menu li {
      padding: 10px 20px;
      cursor: pointer;
      background: #f0f0f0;
      margin-right: 5px;
      border-radius: 5px 5px 0 0;
      transition: all 0.3s;
      white-space: nowrap;
    }
    .tab-menu li:hover {
      background: #e0e0e0;
    }
    .tab-menu li.active {
      background: #007bff;
      color: white;
    }
    .tab-content {
      display: none;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 0 5px 5px 5px;
    }
    .tab-content.active {
      display: block;
    }
    
    /* カードグリッド - モバイル対応 */
    .card-grid-container {
      overflow-x: auto;
      margin: 10px 0;
    }
    #card-grid, #range-grid {
      border-collapse: collapse;
      cursor: pointer;
    }
    #card-grid td {
      padding: 8px 12px;
      border: 1px solid #ddd;
      text-align: center;
      transition: all 0.2s;
      font-weight: bold;
      min-width: 40px;
    }
    
    @media (max-width: 768px) {
      #card-grid td {
        padding: 6px 8px;
        font-size: 14px;
        min-width: 35px;
      }
    }
    
    #card-grid td:hover {
      background-color: #f0f0f0;
    }
    #card-grid td.selected {
      background: #007bff;
      color: white;
    }
    #card-grid td.disabled {
      background: #ccc;
      color: #666;
      cursor: not-allowed;
    }
    
    /* レンジグリッド - モバイル対応 */
    .range-grid-container {
      overflow-x: auto;
      margin: 10px 0;
    }
    #range-grid td {
      font-size: 12px;
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: center;
      transition: all 0.2s;
      font-weight: bold;
      min-width: 35px;
    }
    
    @media (max-width: 768px) {
      #range-grid td {
        font-size: 10px;
        padding: 4px 6px;
        min-width: 30px;
      }
    }
    
    #range-grid td.pair {
      background-color: #ffe4e1;
    }
    #range-grid td.suited {
      background-color: #e6f3ff;
    }
    #range-grid td.offsuit {
      background-color: #f0f0f0;
    }
    #range-grid td:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #range-grid td.active-range {
      background: #28a745;
      color: white;
    }
    #range-grid td.hero-hand {
      border: 3px solid #ff0000;
      box-shadow: 0 0 5px rgba(255,0,0,0.5);
    }
    
    /* カラー */
    .red { color: #ff0000; }
    .black { color: #000000; }
    
    /* 結果表示 */
    .results {
      margin-top: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    @media (max-width: 768px) {
      .results {
        padding: 10px;
      }
      .results p {
        font-size: 14px;
        margin: 8px 0;
      }
    }
    
    .results h3 {
      margin-top: 0;
      color: #333;
    }
    .win-rate {
      font-size: 2em;
      font-weight: bold;
      margin: 10px 0;
    }
    .profitable { color: #28a745; }
    .unprofitable { color: #dc3545; }
    
    /* ボタン */
    button {
      padding: 10px 20px;
      margin: 10px 5px;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      transition: all 0.3s;
      width: auto;
      min-width: 100px;
    }
    
    @media (max-width: 768px) {
      button {
        width: 100%;
        margin: 5px 0;
      }
    }
    
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    
    /* クイックレンジボタン */
    .quick-ranges {
      margin: 10px 0;
    }
    .quick-ranges button {
      padding: 5px 15px;
      font-size: 14px;
      margin: 3px;
    }
    .quick-ranges button.clear {
      background: #dc3545;
    }
    
    /* 選択中の表示 */
    .selection-display {
      padding: 10px;
      background: #e9ecef;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 1em;
    }
    
    @media (max-width: 768px) {
      .selection-display {
        font-size: 14px;
        padding: 8px;
      }
    }
    
    .selection-display span {
      font-weight: bold;
      margin: 0 5px;
    }
    
    /* サンプル数選択 */
    .sample-select {
      margin: 15px 0;
    }
    .sample-select label {
      margin-right: 10px;
      font-weight: bold;
    }
    .sample-select select {
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-size: 16px;
    }
    
    @media (max-width: 768px) {
      .sample-select {
        display: flex;
        flex-direction: column;
      }
      .sample-select label {
        margin-bottom: 5px;
      }
      .sample-select select {
        width: 100%;
        padding: 8px;
      }
    }
    
    /* ICM計算用スタイル */
    .controls {
      margin: 20px 0;
    }
    .controls label {
      margin-right: 15px;
      display: inline-block;
      margin-bottom: 10px;
    }
    .controls select, .controls input {
      padding: 5px;
      margin-right: 10px;
    }
    
    @media (max-width: 768px) {
      .controls {
        display: flex;
        flex-direction: column;
      }
      .controls label {
        margin-bottom: 5px;
      }
      .controls select, .controls input {
        width: 100%;
        margin-bottom: 10px;
        padding: 8px;
      }
    }
    
    .player-inputs {
      margin: 10px 0;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }
    .player-inputs input {
      width: 100px;
      margin: 0 5px;
    }
    .player-inputs select {
      margin-left: 5px;
    }
    
    @media (max-width: 768px) {
      .player-inputs {
        flex-direction: column;
        align-items: stretch;
      }
      .player-inputs input, .player-inputs select {
        width: 100%;
        margin: 5px 0;
        padding: 8px;
      }
    }
    
    #icm-results {
      margin-top: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 5px;
    }
    #icm-results p {
      margin: 5px 0;
    }
    
    /* スクロールヒント */
    .scroll-hint {
      text-align: center;
      color: #666;
      font-size: 12px;
      margin: 5px 0;
      display: none;
    }
    
    @media (max-width: 768px) {
      .scroll-hint {
        display: block;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Poker Equity Calculator</h1>
    
    <ul class="tab-menu">
      <li data-tab="winrate-tab" class="active">勝率計算</li>
      <li data-tab="icm-tab">ICM計算</li>
    </ul>

    <!-- 勝率計算タブ -->
    <div id="winrate-tab" class="tab-content active">
      <h2>ヒーローのハンド</h2>
      <div id="card-selection">
        <p>クリックして2枚のカードを選択してください:</p>
        <div class="scroll-hint">← 横スクロール可能 →</div>
        <div class="card-grid-container">
          <table id="card-grid">
            <tr>
              <td data-card="As" class="black">A♠</td>
              <td data-card="Ks" class="black">K♠</td>
              <td data-card="Qs" class="black">Q♠</td>
              <td data-card="Js" class="black">J♠</td>
              <td data-card="Ts" class="black">T♠</td>
              <td data-card="9s" class="black">9♠</td>
              <td data-card="8s" class="black">8♠</td>
              <td data-card="7s" class="black">7♠</td>
              <td data-card="6s" class="black">6♠</td>
              <td data-card="5s" class="black">5♠</td>
              <td data-card="4s" class="black">4♠</td>
              <td data-card="3s" class="black">3♠</td>
              <td data-card="2s" class="black">2♠</td>
            </tr>
            <tr>
              <td data-card="Ah" class="red">A♥</td>
              <td data-card="Kh" class="red">K♥</td>
              <td data-card="Qh" class="red">Q♥</td>
              <td data-card="Jh" class="red">J♥</td>
              <td data-card="Th" class="red">T♥</td>
              <td data-card="9h" class="red">9♥</td>
              <td data-card="8h" class="red">8♥</td>
              <td data-card="7h" class="red">7♥</td>
              <td data-card="6h" class="red">6♥</td>
              <td data-card="5h" class="red">5♥</td>
              <td data-card="4h" class="red">4♥</td>
              <td data-card="3h" class="red">3♥</td>
              <td data-card="2h" class="red">2♥</td>
            </tr>
            <tr>
              <td data-card="Ad" class="red">A♦</td>
              <td data-card="Kd" class="red">K♦</td>
              <td data-card="Qd" class="red">Q♦</td>
              <td data-card="Jd" class="red">J♦</td>
              <td data-card="Td" class="red">T♦</td>
              <td data-card="9d" class="red">9♦</td>
              <td data-card="8d" class="red">8♦</td>
              <td data-card="7d" class="red">7♦</td>
              <td data-card="6d" class="red">6♦</td>
              <td data-card="5d" class="red">5♦</td>
              <td data-card="4d" class="red">4♦</td>
              <td data-card="3d" class="red">3♦</td>
              <td data-card="2d" class="red">2♦</td>
            </tr>
            <tr>
              <td data-card="Ac" class="black">A♣</td>
              <td data-card="Kc" class="black">K♣</td>
              <td data-card="Qc" class="black">Q♣</td>
              <td data-card="Jc" class="black">J♣</td>
              <td data-card="Tc" class="black">T♣</td>
              <td data-card="9c" class="black">9♣</td>
              <td data-card="8c" class="black">8♣</td>
              <td data-card="7c" class="black">7♣</td>
              <td data-card="6c" class="black">6♣</td>
              <td data-card="5c" class="black">5♣</td>
              <td data-card="4c" class="black">4♣</td>
              <td data-card="3c" class="black">3♣</td>
              <td data-card="2c" class="black">2♣</td>
            </tr>
          </table>
        </div>
        <div class="selection-display">
          選択中: <span id="hand-card1">--</span> <span id="hand-card2">--</span>
          <span id="hand-category"></span>
        </div>
      </div>

      <h2>相手のレンジ</h2>
      <div class="quick-ranges">
        <button onclick="selectRange('clear')" class="clear">クリア</button>
      </div>
      
      <div id="range-selection">
        <p>クリックしてレンジを選択:</p>
        <div class="scroll-hint">← 横スクロール可能 →</div>
        <div class="range-grid-container">
          <table id="range-grid">
            <!-- JavaScriptで生成 -->
          </table>
        </div>
        <div class="selection-display">
          選択中: <span id="range-count">0</span> / 169 ハンド 
          (<span id="range-percent">0.0</span>%)
        </div>
      </div>

      <div class="sample-select">
        <label for="sample-count">サンプル数:</label>
        <select id="sample-count">
          <option value="5000">5,000回 (標準)</option>
          <option value="10000" selected>10,000回 (高精度)</option>
          <option value="25000">25,000回 (最高精度)</option>
        </select>
      </div>

      <button id="calc-winrate-btn">勝率計算</button>
      <div id="winrate-result" class="results"></div>
    </div>

    <!-- ICM計算タブ -->
    <div id="icm-tab" class="tab-content">
      <div class="controls">
        <label>プレイヤー数:
          <select id="num-players">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
          </select>
        </label>
        <button id="generate-btn">生成</button>
        <label>ヒーロー:
          <select id="hero-index"></select>
        </label>
        <label>オールイン相手:
          <select id="allin-index"></select>
        </label>
        <label>オープン額:
          <input type="number" id="open-amount" step="0.1">
        </label>
      </div>
      <div id="player-inputs"></div>
      <div class="actions">
        <button id="calc-icm-btn">ICM計算</button>
      </div>
      <div id="icm-results">
        <p>合計ポット: <span id="total-pot">0.00</span></p>
        <p>コール額: <span id="call-amount">0.00</span></p>
        <p>フォールド時EV: <span id="fold-ev">0.00</span></p>
        <p>勝利時EV: <span id="win-ev">0.00</span></p>
        <p>敗北時EV: <span id="lose-ev">0.00</span></p>
        <p>必要勝率: <span id="required-winrate">0.00%</span></p>
        <div id="ev-list"></div>
      </div>
    </div>
  </div>

  <script>
    // グローバル変数
    let selectedCards = [];
    const HAND_CATEGORIES = [
      'AA','AKs','AQs','AJs','ATs','A9s','A8s','A7s','A6s','A5s','A4s','A3s','A2s',
      'AKo','KK','KQs','KJs','KTs','K9s','K8s','K7s','K6s','K5s','K4s','K3s','K2s',
      'AQo','KQo','QQ','QJs','QTs','Q9s','Q8s','Q7s','Q6s','Q5s','Q4s','Q3s','Q2s',
      'AJo','KJo','QJo','JJ','JTs','J9s','J8s','J7s','J6s','J5s','J4s','J3s','J2s',
      'ATo','KTo','QTo','JTo','TT','T9s','T8s','T7s','T6s','T5s','T4s','T3s','T2s',
      'A9o','K9o','Q9o','J9o','T9o','99','98s','97s','96s','95s','94s','93s','92s',
      'A8o','K8o','Q8o','J8o','T8o','98o','88','87s','86s','85s','84s','83s','82s',
      'A7o','K7o','Q7o','J7o','T7o','97o','87o','77','76s','75s','74s','73s','72s',
      'A6o','K6o','Q6o','J6o','T6o','96o','86o','76o','66','65s','64s','63s','62s',
      'A5o','K5o','Q5o','J5o','T5o','95o','85o','75o','65o','55','54s','53s','52s',
      'A4o','K4o','Q4o','J4o','T4o','94o','84o','74o','64o','54o','44','43s','42s',
      'A3o','K3o','Q3o','J3o','T3o','93o','83o','73o','63o','53o','43o','33','32s',
      'A2o','K2o','Q2o','J2o','T2o','92o','82o','72o','62o','52o','42o','32o','22'
    ];
    
    // カードランクとスート
    const ranks = ['A','K','Q','J','T','9','8','7','6','5','4','3','2'];
    const suits = ['s', 'h', 'd', 'c'];
    const suitSymbols = { 's': '♠', 'h': '♥', 'd': '♦', 'c': '♣' };
    const RANK_VALUES = {
      'A':14, 'K':13, 'Q':12, 'J':11, 'T':10,
      '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2
    };
    
    // デッキ作成
    function createDeck() {
      const deck = [];
      for (const rank of ranks) {
        for (const suit of suits) {
          deck.push(rank + suit);
        }
      }
      return deck;
    }
    
    // 組み合わせを生成
    function* combinations(array, k) {
      if (k === 1) {
        for (const item of array) {
          yield [item];
        }
        return;
      }
      
      for (let i = 0; i <= array.length - k; i++) {
        const head = array[i];
        const tailCombos = combinations(array.slice(i + 1), k - 1);
        for (const combo of tailCombos) {
          yield [head, ...combo];
        }
      }
    }
    
    // 5枚の役を評価
    function evaluateFive(cards) {
      const ranks = cards.map(c => RANK_VALUES[c[0]]).sort((a,b) => b-a);
      const suits = cards.map(c => c[1]);
      
      // フラッシュ判定
      const isFlush = new Set(suits).size === 1;
      
      // ストレート判定
      let isStraight = false;
      const uniqueRanks = [...new Set(ranks)].sort((a,b) => b-a);
      if (uniqueRanks.length >= 5) {
        for (let i = 0; i <= uniqueRanks.length - 5; i++) {
          if (uniqueRanks[i] - uniqueRanks[i+4] === 4) {
            isStraight = true;
            break;
          }
        }
      }
      // A-5ストレート
      if (!isStraight && uniqueRanks.includes(14) && uniqueRanks.includes(2) && 
          uniqueRanks.includes(3) && uniqueRanks.includes(4) && uniqueRanks.includes(5)) {
        isStraight = true;
      }
      
      // ランクカウント
      const rankCounts = {};
      for (const rank of ranks) {
        rankCounts[rank] = (rankCounts[rank] || 0) + 1;
      }
      const counts = Object.values(rankCounts).sort((a,b) => b-a);
      
      // 役の強さを計算
      let score = 0;
      if (isStraight && isFlush) {
        score = 9000000 + Math.max(...ranks);
      } else if (counts[0] === 4) {
        const fourRank = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
        score = 8000000 + parseInt(fourRank) * 10000;
      } else if (counts[0] === 3 && counts[1] === 2) {
        const threeRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
        const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
        score = 7000000 + parseInt(threeRank) * 10000 + parseInt(pairRank) * 100;
      } else if (isFlush) {
        score = 6000000;
        for (let i = 0; i < ranks.length; i++) {
          score += ranks[i] * Math.pow(15, 4-i);
        }
      } else if (isStraight) {
        score = 5000000 + Math.max(...ranks);
      } else if (counts[0] === 3) {
        const threeRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
        score = 4000000 + parseInt(threeRank) * 10000;
      } else if (counts[0] === 2 && counts[1] === 2) {
        const pairs = Object.keys(rankCounts).filter(r => rankCounts[r] === 2)
                            .map(r => parseInt(r)).sort((a,b) => b-a);
        score = 3000000 + pairs[0] * 10000 + pairs[1] * 100;
      } else if (counts[0] === 2) {
        const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
        score = 2000000 + parseInt(pairRank) * 10000;
      } else {
        score = 1000000;
        for (let i = 0; i < ranks.length; i++) {
          score += ranks[i] * Math.pow(15, 4-i);
        }
      }
      
      return score;
    }
    
    // 7枚から最高の5枚を評価
    function evaluate(cards) {
      let best = 0;
      for (const five of combinations(cards, 5)) {
        const score = evaluateFive(five);
        if (score > best) best = score;
      }
      return best;
    }
    
    // ランダムサンプル
    function sample(array, n) {
      const result = [];
      const copy = [...array];
      for (let i = 0; i < n; i++) {
        const idx = Math.floor(Math.random() * copy.length);
        result.push(copy[idx]);
        copy.splice(idx, 1);
      }
      return result;
    }
    
    // レンジグリッドの生成
    function generateRangeGrid() {
      const rangeGrid = document.getElementById('range-grid');
      const rangeLayout = [
        ['AA','AKs','AQs','AJs','ATs','A9s','A8s','A7s','A6s','A5s','A4s','A3s','A2s'],
        ['AKo','KK','KQs','KJs','KTs','K9s','K8s','K7s','K6s','K5s','K4s','K3s','K2s'],
        ['AQo','KQo','QQ','QJs','QTs','Q9s','Q8s','Q7s','Q6s','Q5s','Q4s','Q3s','Q2s'],
        ['AJo','KJo','QJo','JJ','JTs','J9s','J8s','J7s','J6s','J5s','J4s','J3s','J2s'],
        ['ATo','KTo','QTo','JTo','TT','T9s','T8s','T7s','T6s','T5s','T4s','T3s','T2s'],
        ['A9o','K9o','Q9o','J9o','T9o','99','98s','97s','96s','95s','94s','93s','92s'],
        ['A8o','K8o','Q8o','J8o','T8o','98o','88','87s','86s','85s','84s','83s','82s'],
        ['A7o','K7o','Q7o','J7o','T7o','97o','87o','77','76s','75s','74s','73s','72s'],
        ['A6o','K6o','Q6o','J6o','T6o','96o','86o','76o','66','65s','64s','63s','62s'],
        ['A5o','K5o','Q5o','J5o','T5o','95o','85o','75o','65o','55','54s','53s','52s'],
        ['A4o','K4o','Q4o','J4o','T4o','94o','84o','74o','64o','54o','44','43s','42s'],
        ['A3o','K3o','Q3o','J3o','T3o','93o','83o','73o','63o','53o','43o','33','32s'],
        ['A2o','K2o','Q2o','J2o','T2o','92o','82o','72o','62o','52o','42o','32o','22']
      ];
      
      rangeLayout.forEach((row, i) => {
        const tr = document.createElement('tr');
        row.forEach((hand, j) => {
          const td = document.createElement('td');
          td.textContent = hand;
          const catIndex = HAND_CATEGORIES.indexOf(hand);
          td.dataset.cat = catIndex;
          td.dataset.hand = hand;
          
          // スタイルクラス
          if (hand[0] === hand[1]) {
            td.classList.add('pair');
          } else if (hand.endsWith('s')) {
            td.classList.add('suited');
          } else {
            td.classList.add('offsuit');
          }
          
          tr.appendChild(td);
        });
        rangeGrid.appendChild(tr);
      });
    }
    
    // カード選択処理
    function handleCardClick(e) {
      const cell = e.currentTarget;
      const card = cell.dataset.card;
      
      const idx = selectedCards.indexOf(card);
      
      if (idx !== -1) {
        // 選択解除
        selectedCards.splice(idx, 1);
        cell.classList.remove('selected');
      } else {
        if (selectedCards.length === 2) {
          // 既に2枚選択されている場合、最初のカードを解除
          const firstCard = selectedCards.shift();
          document.querySelector(`[data-card="${firstCard}"]`).classList.remove('selected');
        }
        
        // 新しいカードを選択
        selectedCards.push(card);
        cell.classList.add('selected');
      }
      
      updateHandDisplay();
    }
    
    // ハンド表示更新
    function updateHandDisplay() {
      const card1Display = document.getElementById('hand-card1');
      const card2Display = document.getElementById('hand-card2');
      const categoryDisplay = document.getElementById('hand-category');
      
      if (selectedCards[0]) {
        const rank = selectedCards[0][0];
        const suit = selectedCards[0][1];
        card1Display.innerHTML = rank + suitSymbols[suit];
        card1Display.className = (suit === 'h' || suit === 'd') ? 'red' : 'black';
      } else {
        card1Display.textContent = '--';
        card1Display.className = '';
      }
      
      if (selectedCards[1]) {
        const rank = selectedCards[1][0];
        const suit = selectedCards[1][1];
        card2Display.innerHTML = rank + suitSymbols[suit];
        card2Display.className = (suit === 'h' || suit === 'd') ? 'red' : 'black';
      } else {
        card2Display.textContent = '--';
        card2Display.className = '';
      }
      
      // カテゴリー表示とヒーローハンド強調
      document.querySelectorAll('#range-grid td').forEach(cell => {
        cell.classList.remove('hero-hand');
      });
      
      if (selectedCards.length === 2) {
        const category = getHandCategory(selectedCards[0], selectedCards[1]);
        categoryDisplay.textContent = `(${category})`;
        const catId = HAND_CATEGORIES.indexOf(category);
        if (catId !== -1) {
          const cell = document.querySelector(`#range-grid td[data-cat="${catId}"]`);
          if (cell) {
            cell.classList.add('hero-hand');
          }
        }
      } else {
        categoryDisplay.textContent = '';
      }
    }
    
    // カードからカテゴリーを取得
    function getHandCategory(card1, card2) {
      const rank1 = card1[0];
      const rank2 = card2[0];
      const suit1 = card1[1];
      const suit2 = card2[1];
      
      const rankIndex1 = ranks.indexOf(rank1);
      const rankIndex2 = ranks.indexOf(rank2);
      
      // ポケットペア
      if (rank1 === rank2) {
        return rank1 + rank1;
      }
      
      // 高い方を先に
      const [highRank, lowRank] = rankIndex1 < rankIndex2 ? [rank1, rank2] : [rank2, rank1];
      
      // スーテッドかオフスート
      const suited = suit1 === suit2;
      return highRank + lowRank + (suited ? 's' : 'o');
    }
    
    // レンジ選択処理
    function handleRangeClick(e) {
      const cell = e.currentTarget;
      cell.classList.toggle('active-range');
      updateRangeDisplay();
    }
    
    // レンジ表示更新
    function updateRangeDisplay() {
      const selectedCells = document.querySelectorAll('#range-grid td.active-range');
      const count = selectedCells.length;
      const percent = (count / 169 * 100).toFixed(1);
      
      document.getElementById('range-count').textContent = count;
      document.getElementById('range-percent').textContent = percent;
    }
    
    // プリセットレンジ選択
    function selectRange(type) {
      // 全てクリア
      document.querySelectorAll('#range-grid td').forEach(td => {
        td.classList.remove('active-range');
      });
      
      updateRangeDisplay();
    }
    
    // 組み合わせを取得（ブロッカー考慮）
    function getCombosForHand(handCategory, blockedCards) {
      const deck = createDeck();
      const combos = [];
      
      if (handCategory.length === 2 && handCategory[0] === handCategory[1]) {
        // ポケットペア
        const rank = handCategory[0];
        const rankCards = deck.filter(c => c[0] === rank && !blockedCards.includes(c));
        for (const combo of combinations(rankCards, 2)) {
          combos.push(combo);
        }
      } else if (handCategory.endsWith('s')) {
        // スーテッド
        const r1 = handCategory[0];
        const r2 = handCategory[1];
        for (const suit of suits) {
          const c1 = r1 + suit;
          const c2 = r2 + suit;
          if (!blockedCards.includes(c1) && !blockedCards.includes(c2)) {
            combos.push([c1, c2]);
          }
        }
      } else if (handCategory.endsWith('o')) {
        // オフスート
        const r1 = handCategory[0];
        const r2 = handCategory[1];
        for (const s1 of suits) {
          for (const s2 of suits) {
            if (s1 !== s2) {
              const c1 = r1 + s1;
              const c2 = r2 + s2;
              if (!blockedCards.includes(c1) && !blockedCards.includes(c2)) {
                combos.push([c1, c2]);
              }
            }
          }
        }
      }
      
      return combos;
    }
    
    // 勝率計算（モンテカルロ法）
    async function calculateWinRate() {
      const winrateResultDiv = document.getElementById('winrate-result');
      const calcButton = document.getElementById('calc-winrate-btn');
      
      if (selectedCards.length !== 2) {
        winrateResultDiv.innerHTML = '<p style="color: red;">手札を2枚選択してください</p>';
        return;
      }
      
      // 選択されたレンジのカテゴリーを取得
      const villainCells = document.querySelectorAll('#range-grid td.active-range');
      if (villainCells.length === 0) {
        winrateResultDiv.innerHTML = '<p style="color: red;">相手のレンジを選択してください</p>';
        return;
      }
      
      // ボタンを無効化
      calcButton.disabled = true;
      calcButton.textContent = '計算中...';
      
      const sampleCount = parseInt(document.getElementById('sample-count').value);
      const startTime = performance.now();
      
      // ヒーローハンド
      const heroCards = selectedCards;
      const heroCategory = getHandCategory(heroCards[0], heroCards[1]);
      
      // 相手の全組み合わせを取得（ブロッカー考慮）
      const allVillainCombos = [];
      villainCells.forEach(cell => {
        const handCategory = cell.dataset.hand;
        const combos = getCombosForHand(handCategory, heroCards);
        allVillainCombos.push(...combos);
      });
      
      if (allVillainCombos.length === 0) {
        winrateResultDiv.innerHTML = '<p style="color: red;">ブロッカー効果により、相手の有効な組み合わせがありません</p>';
        calcButton.disabled = false;
        calcButton.textContent = '勝率計算';
        return;
      }
      
      // 進捗表示
      winrateResultDiv.innerHTML = `
        <p>計算中... (相手の組み合わせ: ${allVillainCombos.length})</p>
        <p>進捗: <span id="calc-progress">0</span> / ${allVillainCombos.length}</p>
      `;
      
      // モンテカルロシミュレーション（非同期処理）
      const deck = createDeck();
      let totalEquity = 0;
      let processedCombos = 0;
      
      // バッチ処理で計算
      const batchSize = 5; // 一度に処理する組み合わせ数
      
      for (let batchStart = 0; batchStart < allVillainCombos.length; batchStart += batchSize) {
        // UIを更新するための非同期処理
        await new Promise(resolve => setTimeout(resolve, 0));
        
        const batchEnd = Math.min(batchStart + batchSize, allVillainCombos.length);
        
        for (let idx = batchStart; idx < batchEnd; idx++) {
          const villainCards = allVillainCombos[idx];
          let wins = 0;
          let ties = 0;
          
          // 使用済みカードを除外
          const usedCards = [...heroCards, ...villainCards];
          const remainingDeck = deck.filter(c => !usedCards.includes(c));
          
          // サンプルボード数だけシミュレーション
          for (let i = 0; i < sampleCount; i++) {
            const board = sample(remainingDeck, 5);
            
            const heroScore = evaluate([...heroCards, ...board]);
            const villainScore = evaluate([...villainCards, ...board]);
            
            if (heroScore > villainScore) {
              wins++;
            } else if (heroScore === villainScore) {
              ties++;
            }
          }
          
          const matchupEquity = (wins + ties * 0.5) / sampleCount;
          totalEquity += matchupEquity;
          processedCombos++;
        }
        
        // 進捗更新
        document.getElementById('calc-progress').textContent = processedCombos;
      }
      
      const heroWinRate = (totalEquity / allVillainCombos.length) * 100;
      const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
      const totalBoards = sampleCount * allVillainCombos.length;
      
      // 誤差範囲を計算（95%信頼区間）
      const p = heroWinRate / 100;
      const stderr = Math.sqrt((p * (1 - p)) / (sampleCount * allVillainCombos.length));
      const errorMargin = (stderr * 1.96 * 100).toFixed(2);
      
      // 結果を詳細に表示
      winrateResultDiv.innerHTML = `
        <h3>計算結果</h3>
        <p>ヒーロー: <strong>${heroCards[0]} ${heroCards[1]} (${heroCategory})</strong></p>
        <p>相手レンジ: ${villainCells.length}種類 / 169種類 (${(villainCells.length / 169 * 100).toFixed(1)}%)</p>
        <p>相手の実際の組み合わせ数: ${allVillainCombos.length} (ブロッカー考慮後)</p>
        <p>総シミュレーション数: ${totalBoards.toLocaleString()}回</p>
        <p>計算時間: ${elapsed}秒</p>
        <hr>
        <p>勝率: <strong style="font-size: 1.5em; color: ${heroWinRate >= 50 ? 'green' : 'red'}">${heroWinRate.toFixed(2)}%</strong></p>
        <p style="font-size: 0.9em; color: #666;">95%信頼区間: ±${errorMargin}%</p>
      `;
      
      // ボタンを有効化
      calcButton.disabled = false;
      calcButton.textContent = '勝率計算';
    }
    
    // ICM計算関数
    function generatePlayerInputs() {
      const n = parseInt(document.getElementById('num-players').value);
      const playerInputsDiv = document.getElementById('player-inputs');
      const heroIndexSelect = document.getElementById('hero-index');
      const allinIndexSelect = document.getElementById('allin-index');
      
      playerInputsDiv.innerHTML = '';
      heroIndexSelect.innerHTML = '';
      allinIndexSelect.innerHTML = '';

      for (let i = 0; i < n; i++) {
        const div = document.createElement('div');
        div.className = 'player-inputs';
        div.innerHTML = `
          P${i+1}:
          <input type="number" id="stack${i}" step="0.1" placeholder="スタック">
          <input type="number" id="prize${i}" step="0.1" placeholder="プライズ">
          <select id="role${i}">
            <option value="none">その他</option>
            <option value="sb">SB</option>
            <option value="bb">BB</option>
            <option value="open">オープン</option>
          </select>`;
        playerInputsDiv.appendChild(div);
        
        const optHero = document.createElement('option');
        optHero.value = i;
        optHero.text = `P${i+1}`;
        heroIndexSelect.appendChild(optHero);
        
        const optAllin = document.createElement('option');
        optAllin.value = i;
        optAllin.text = `P${i+1}`;
        allinIndexSelect.appendChild(optAllin);
      }
    }
    
    function calculateICM() {
      const n = parseInt(document.getElementById('num-players').value);
      const stacks = [], prizes = [], roles = [];
      
      for (let i = 0; i < n; i++) {
        stacks.push(parseFloat(document.getElementById(`stack${i}`).value) || 0);
        prizes.push(parseFloat(document.getElementById(`prize${i}`).value) || 0);
        roles.push(document.getElementById(`role${i}`).value);
      }
      
      const heroIndex = parseInt(document.getElementById('hero-index').value);
      const allinIndex = parseInt(document.getElementById('allin-index').value);
      const openAmount = parseFloat(document.getElementById('open-amount').value) || 0;
      const heroStack = stacks[heroIndex];
      const allinStack = stacks[allinIndex];

      let adjustedHeroStack = heroStack;
      if (roles[heroIndex] === 'bb') {
          adjustedHeroStack = Math.max(0, heroStack - 1.0);
      }
      
      let contested = Math.min(adjustedHeroStack, allinStack);

      let openIndex = -1;
      let openAmountUsed = 0;
      const B = stacks.slice();
      let pot = 0;
      
      for (let i = 0; i < n; i++) {
       if (roles[i] === 'bb') {
         const ante = Math.min(B[i], 1.0);
         B[i] -= ante;
         pot += ante;
         break;
       }
      }
      
      if (roles[heroIndex] === 'open') {
        openIndex = heroIndex;
        openAmountUsed = openAmount > contested ? contested : openAmount;
        openAmountUsed = Math.min(openAmountUsed, B[heroIndex]);
        B[heroIndex] -= openAmountUsed;
        pot += openAmountUsed;
      } else {
        for (let i = 0; i < n; i++) {
          if (roles[i] === 'open' && i !== heroIndex) {
            openIndex = i;
            openAmountUsed = openAmount > contested ? contested : openAmount;
            openAmountUsed = Math.min(openAmountUsed, B[i]);
            B[i] -= openAmountUsed;
            pot += openAmountUsed;
            break;
          }
        }
      }

      let allinAmount = contested;
      if (roles[allinIndex] === 'bb') {
        allinAmount = Math.max(0, allinAmount - 1.0);
        pot += 1.0;
      }
      if (openIndex === allinIndex) {
        allinAmount -= openAmountUsed;
        if (allinAmount < 0) allinAmount = 0;
      }
      
      pot += allinAmount;
      B[allinIndex] = Math.max(B[allinIndex] - allinAmount, 0);
      
      for (let i = 0; i < n; i++) {
        if (roles[i] === 'sb' && i !== allinIndex) {
          const sbBlind = Math.min(B[i], 0.5);
          B[i] -= sbBlind;
          pot += sbBlind;
        }
        if (roles[i] === 'bb' && i !== allinIndex) {
          const bbBlind = Math.min(B[i], 1.0);
          B[i] -= bbBlind;
          pot += bbBlind;
        }
      }

      let callAmount = 0;
      if (roles[heroIndex] === 'open') {
        callAmount = Math.max(0, contested - openAmountUsed);
      } else {
        let heroBlind = 0;
        if (roles[heroIndex] === 'sb') heroBlind = 0.5;
        if (roles[heroIndex] === 'bb') heroBlind = 1.0;
        callAmount = Math.max(0, contested - heroBlind);
      }

      const stacksFold = B.slice();
      const stacksWin  = B.slice();
      const stacksLose = B.slice();

      stacksWin[heroIndex]  = Math.max(stacksWin[heroIndex] - callAmount, 0);
      stacksLose[heroIndex] = Math.max(stacksLose[heroIndex] - callAmount, 0);
      
      stacksWin[heroIndex]   += pot + callAmount;
      stacksLose[allinIndex] += pot + callAmount;
      stacksFold[allinIndex] += pot;

      const foldEV = computeICMRecursive(stacksFold, prizes)[heroIndex];
      const winEV  = computeICMRecursive(stacksWin,  prizes)[heroIndex];
      const loseEV = computeICMRecursive(stacksLose, prizes)[heroIndex];

      const requiredPct = (foldEV - loseEV) / (winEV - loseEV) * 100;

      document.getElementById('total-pot').textContent = pot.toFixed(2);
      document.getElementById('call-amount').textContent = callAmount.toFixed(2);
      document.getElementById('fold-ev').textContent = foldEV.toFixed(2);
      document.getElementById('win-ev').textContent = winEV.toFixed(2);
      document.getElementById('lose-ev').textContent = loseEV.toFixed(2);
      document.getElementById('required-winrate').textContent = requiredPct.toFixed(2) + '%';

      const allEV = computeICMRecursive(stacks, prizes);
      const evListDiv = document.getElementById('ev-list');
      evListDiv.innerHTML = '開始時ICM:<br>';
      allEV.forEach((val, idx) => {
        evListDiv.innerHTML += `P${idx+1}: ${val.toFixed(2)}<br>`;
      });
    }

    function computeICMRecursive(stacks, prizes) {
      const n = stacks.length;
      const payouts = prizes.slice();
      while (payouts.length < n) {
        payouts.push(0);
      }
      const results = new Array(n).fill(0);

      function recurse(activeIndices, remainingPayouts, probFactor) {
        const m = activeIndices.length;
        if (m === 0) return;
        if (m === 1) {
          const playerIndex = activeIndices[0];
          results[playerIndex] += probFactor * (remainingPayouts[0] || 0);
          return;
        }
        let totalChips = 0;
        activeIndices.forEach(idx => {
          totalChips += stacks[idx];
        });
        const topPrize = remainingPayouts[0] || 0;
        for (let j = 0; j < m; j++) {
          const playerIndex = activeIndices[j];
          const chips = stacks[playerIndex];
          const p = (totalChips > 0 ? chips / totalChips : 0);
          results[playerIndex] += probFactor * p * topPrize;
          const newActive = activeIndices.slice(0, j).concat(activeIndices.slice(j+1));
          recurse(newActive, remainingPayouts.slice(1), probFactor * p);
        }
      }

      const initialIndices = stacks.map((_, idx) => idx);
      recurse(initialIndices, payouts, 1);
      return results;
    }
    
    // イベントリスナーの設定
    document.addEventListener('DOMContentLoaded', () => {
      // レンジグリッド生成
      generateRangeGrid();
      
      // カードクリックイベント
      document.querySelectorAll('#card-grid td').forEach(cell => {
        cell.addEventListener('click', handleCardClick);
      });
      
      // レンジクリックイベント
      document.querySelectorAll('#range-grid td').forEach(cell => {
        cell.addEventListener('click', handleRangeClick);
      });
      
      // 計算ボタン
      document.getElementById('calc-winrate-btn').addEventListener('click', calculateWinRate);
      
      // ICM関連
      generatePlayerInputs();
      document.getElementById('generate-btn').addEventListener('click', generatePlayerInputs);
      document.getElementById('calc-icm-btn').addEventListener('click', calculateICM);
      
      // タブ切り替え
      document.querySelectorAll('.tab-menu li').forEach(tab => {
        tab.addEventListener('click', function() {
          const targetId = this.dataset.tab;
          
          document.querySelectorAll('.tab-menu li').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          
          this.classList.add('active');
          document.getElementById(targetId).classList.add('active');
        });
      });
    });
  </script>
</body>
</html>
